#pragma once

#include <algorithm>
#include <numeric>

namespace met::detail {
  template<size_t Cols, size_t Rows>
  constexpr size_t array_idx(size_t col, size_t row) {
    return row * Cols + col;
  }

  template <size_t Cols, size_t Rows>
  consteval size_t array_size() {
    return Cols * Rows;
  }

  template <size_t Cols, size_t Rows>
  consteval size_t array_reserved_size() {
    size_t power = 1;
    while (power < array_size<Cols, Rows>())
      power <<= 1;    
    return power;
  }
} // met::detail

#define met_array_import_base(T, Cols, Rows, C)                 \
private:                                                        \
  using base_type  = Array<T, Cols, Rows, C>;                   \
  using mask_type  = ArrayMask<Cols, Rows, C>;                  \
  using value_type = base_type::value_type;                     \
  using ref_type   = base_type::ref_type;                       \
  using ptr_type   = base_type::ptr_type;                       \
  using cref_type  = base_type::cref_type;                      \
  using size_type  = base_type::size_type;                      \
public:                                                         \
  using base_type::base_type;                                   \
private:

#define met_array_import_op_add(Ty)                             \
  constexpr Ty operator+(const Ty &a) const noexcept {          \
    auto b = *this;                                             \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] += a[i];                                             \
    return b;                                                   \
  }                                                             \
  constexpr Ty operator+(const value_type &v) const noexcept {  \
    auto b = *this;                                             \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] += v;                                                \
    return b;                                                   \
  }                                                             \
  constexpr Ty & operator+=(const Ty &a) noexcept {             \
    auto &b = *this;                                            \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] += a[i];                                             \
    return b;                                                   \
  }                                                             \
  constexpr Ty & operator+=(const value_type &v) noexcept {     \
    auto &b = *this;                                            \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] += v;                                                \
    return b;                                                   \
  }

#define met_array_import_op_sub(Ty)                             \
  constexpr Ty operator-(const Ty &a) const noexcept {          \
    auto b = *this;                                             \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] -= a[i];                                             \
    return b;                                                   \
  }                                                             \
  constexpr Ty operator-(const value_type &v) const noexcept {  \
    auto b = *this;                                             \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] -= v;                                                \
    return b;                                                   \
  }                                                             \
  constexpr Ty & operator-=(const Ty &a) noexcept {             \
    auto &b = *this;                                            \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] -= a[i];                                             \
    return b;                                                   \
  }                                                             \
  constexpr Ty & operator-=(const value_type &v) noexcept {     \
    auto &b = *this;                                            \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] -= v;                                                \
    return b;                                                   \
  }

#define met_array_import_op_mul(Ty)                             \
  constexpr Ty operator*(const Ty &a) const noexcept {          \
    auto b = *this;                                             \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] *= a[i];                                             \
    return b;                                                   \
  }                                                             \
  constexpr Ty operator*(const value_type &v) const noexcept {  \
    auto b = *this;                                             \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] *= v;                                                \
    return b;                                                   \
  }                                                             \
  constexpr Ty & operator*=(const Ty &a) noexcept {             \
    auto &b = *this;                                            \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] *= a[i];                                             \
    return b;                                                   \
  }                                                             \
  constexpr Ty & operator*=(const value_type &v) noexcept {     \
    auto &b = *this;                                            \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] *= v;                                                \
    return b;                                                   \
}

#define met_array_import_op_div(Ty)                             \
  constexpr Ty operator/(const Ty &a) const noexcept {          \
    auto b = *this;                                             \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] /= a[i];                                             \
    return b;                                                   \
  }                                                             \
  constexpr Ty operator/(const value_type &v) const noexcept {  \
    auto b = *this;                                             \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] /= v;                                                \
    return b;                                                   \
  }                                                             \
  constexpr Ty & operator/=(const Ty &a) noexcept {             \
    auto &b = *this;                                            \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] /= a[i];                                             \
    return b;                                                   \
  }                                                             \
  constexpr Ty & operator/=(const value_type &v) noexcept {     \
    auto &b = *this;                                            \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] /= v;                                                \
    return b;                                                   \
  }

#define met_array_import_op_com(Ty)                             \
  constexpr mask_type operator==(const Ty &a) const noexcept {  \
    mask_type m;                                                \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      m[i] = base_type::operator[](i) == a[i];                  \
    return m;                                                   \
  }                                                             \
  constexpr mask_type operator!=(const Ty &a) const noexcept {  \
    mask_type m;                                                \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      m[i] = base_type::operator[](i) != a[i];                  \
    return m;                                                   \
  }                                                             \
  constexpr mask_type operator>=(const Ty &a) const noexcept {  \
    mask_type m;                                                \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      m[i] = base_type::operator[](i) >= a[i];                  \
    return m;                                                   \
  }                                                             \
  constexpr mask_type operator<=(const Ty &a) const noexcept {  \
    mask_type m;                                                \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      m[i] = base_type::operator[](i) <= a[i];                  \
    return m;                                                   \
  }                                                             \
  constexpr mask_type operator>(const Ty &a) const noexcept {   \
    mask_type m;                                                \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      m[i] = base_type::operator[](i) > a[i];                   \
    return m;                                                   \
  }                                                             \
  constexpr mask_type operator<(const Ty &a) const noexcept {   \
    mask_type m;                                                \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      m[i] = base_type::operator[](i) < a[i];                   \
    return m;                                                   \
  }                                                             

#define met_array_import_reduc(Ty)                              \
  constexpr value_type min_value() const noexcept {             \
    return *std::min_element(base_type::begin(),                \
                             base_type::end());                 \
  }                                                             \
  constexpr value_type max_value() const noexcept {             \
    return *std::max_element(base_type::begin(),                \
                             base_type::end());                 \
  }                                                             \
  constexpr value_type sum() const noexcept {                   \
    return std::reduce(++base_type::begin(),                    \
                       base_type::end(),                        \
                       *base_type::begin(),                     \
                       std::plus<>());                          \
  }                                                             \
  constexpr value_type prod() const noexcept {                  \
    return std::reduce(++base_type::begin(),                    \
                       base_type::end(),                        \
                       *base_type::begin(),                     \
                       std::multiplies<>());                    \
  }                                                             \
  constexpr value_type mean() const noexcept {                  \
    return static_cast<value_type>(                             \
      static_cast<float>(sum()) /                               \
      static_cast<float>(base_type::size())                     \
    );                                                          \
  }                                                             

#define met_array_import_redhv(Ty)                              \
protected:                                                      \
  using cols_type = Ty<value_type, Cols, 1, C>;                 \
  using rows_type = Ty<value_type, Rows, 1, C>;                 \
public:                                                         \
  constexpr cols_type col_at(size_type row) const {             \
    cols_type b;                                                \
    for (int i = 0; i < base_type::cols(); ++i)                 \
      b[i] = at(i, row);                                        \
    return b;                                                   \
  }                                                             \
  constexpr rows_type row_at(size_type col) const {             \
    rows_type b;                                                \
    for (int i = 0; i < base_type::rows(); ++i)                 \
      b[i] = at(col, i);                                        \
    return b;                                                   \
  }                                                             \
  constexpr cols_type hsum() const noexcept {                   \
    cols_type b;                                                \
    for (int i = 0; i < base_type::cols(); ++i)                 \
      b[i] = row_at(i).sum();                                   \
    return b;                                                   \
  }                                                             \
  constexpr rows_type vsum() const noexcept {                   \
    rows_type b;                                                \
    for (int i = 0; i < base_type::rows(); ++i)                 \
      b[i] = col_at(i).sum();                                   \
    return b;                                                   \
  }                                                             \
  constexpr cols_type hprod() const noexcept {                  \
    cols_type b;                                                \
    for (int i = 0; i < base_type::cols(); ++i)                 \
      b[i] = row_at(i).prod();                                  \
    return b;                                                   \
  }                                                             \
  constexpr rows_type vprod() const noexcept {                  \
    rows_type b;                                                \
    for (int i = 0; i < base_type::rows(); ++i)                 \
      b[i] = col_at(i).prod();                                  \
    return b;                                                   \
  }                                                             \
  constexpr cols_type hmean() const noexcept {                  \
    cols_type b;                                                \
    for (int i = 0; i < base_type::cols(); ++i)                 \
      b[i] = row_at(i).mean();                                  \
    return b;                                                   \
  }                                                             \
  constexpr rows_type vmean() const noexcept {                  \
    rows_type b;                                                \
    for (int i = 0; i < base_type::rows(); ++i)                 \
      b[i] = col_at(i).mean();                                  \
    return b;                                                   \
  }

#define met_array_import_modif(Ty)                              \
  constexpr Ty min(const Ty &a) const noexcept {                \
    Ty b;                                                       \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] = std::min(base_type::operator[](i), a[i]);          \
    return b;                                                   \
  }                                                             \
  constexpr Ty max(const Ty &a) const noexcept {                \
    Ty b;                                                       \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] = std::max(base_type::operator[](i), a[i]);          \
    return b;                                                   \
  }                                                             \
  constexpr Ty clamp(const Ty &min,                             \
                     const Ty &max) const noexcept {            \
    Ty b;                                                       \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] = std::clamp(base_type::operator[](i),               \
                        min[i], max[i]);                        \
    return b;                                                   \
  }                                                             \
  constexpr Ty clamp(const value_type &min,                     \
                     const value_type &max) const noexcept {    \
    Ty b;                                                       \
    for (size_type i = 0; i < base_type::reserved_size(); ++i)  \
      b[i] = std::clamp(base_type::operator[](i), min, max);    \
    return b;                                                   \
  }                                                             \
  constexpr value_type dot(const Ty &a) const noexcept {        \
    return operator*(a).sum();                                  \
  }                                                             \
  friend constexpr                                              \
  Ty min(const Ty &a, const Ty &b) noexcept {                   \
    return a.min(b);                                            \
  }                                                             \
  friend constexpr                                              \
  Ty max(const Ty &a, const Ty &b) noexcept {                   \
    return a.max(b);                                            \
  }                                                             \
  friend constexpr                                              \
  Ty clamp(const Ty &a, const Ty &min, const Ty &max) noexcept {\
    return a.clamp(min, max);                                   \
  }                                                             \
  friend constexpr                                              \
  Ty clamp(const Ty &a, const value_type &min,                  \
                        const value_type &max) noexcept {       \
    return a.clamp(min, max);                                   \
  }                                                             \
  friend constexpr                                              \
  value_type dot(const Ty &a, const Ty &b) noexcept {           \
    return a.dot(b);                                            \
  }                                                             