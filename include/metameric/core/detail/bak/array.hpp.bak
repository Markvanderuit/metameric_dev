#pragma once

#include <array>
#include <span>
#include <sstream>
#include <metameric/core/detail/array.hpp>

namespace met {
  // Forward declarations
  template <typename T, size_t Cols, size_t Rows, 
            template <typename, size_t> typename C = std::array>
  class Array;
  template <size_t Cols, size_t Rows, 
            template <typename, size_t> typename C = std::array>
  class ArrayMask;

  template <typename T, size_t Cols, size_t Rows,
            template <typename, size_t> typename C>
  class Array {
  protected:
    using value_type = T;
    using ref_type   = T &;
    using ptr_type   = T *;
    using cref_type  = const T &;
    using size_type  = size_t;

    using base_type  = Array;
    using mask_type  = ArrayMask<Cols, Rows, C>;

  private:
    alignas(sizeof(value_type)) 
    C<value_type, detail::array_reserved_size<Cols, Rows>()> m_cont;

  public:
    /* constrs */

    constexpr
    Array() : Array(0.f) { };

    constexpr
    Array(value_type value) { 
      std::fill(begin(), end(), value);
    }

    constexpr
    Array(std::span<value_type> values) {
      std::copy(values.begin(), values.end(), begin());
    }

    /* size information */

    constexpr 
    size_type size() const noexcept {
      return detail::array_size<Cols, Rows>();
    }

    constexpr 
    size_type reserved_size() const noexcept {
      return detail::array_reserved_size<Cols, Rows>();
    }

    constexpr
    size_type cols() const noexcept {
      return Cols;
    }

    constexpr
    size_type rows() const noexcept {
      return Rows;
    }

    /* accessors */

    constexpr
    ref_type at(size_type i) {
      return m_cont[i];
    }

    constexpr
    cref_type at(size_type i) const { 
      return m_cont[i];
    }

    constexpr
    ref_type at(size_type col, size_type row) {
      return m_cont[detail::array_idx<Cols, Rows>(col, row)]; 
    }

    constexpr
    cref_type at(size_type col, size_type row) const {
      return m_cont[detail::array_idx<Cols, Rows>(col, row)]; 
    }

    constexpr
    ref_type operator[](size_type i) { 
      return m_cont[i];
    }

    constexpr
    cref_type operator[](size_type i) const { 
      return m_cont[i];
    }

    constexpr
    ref_type operator()(size_type col, size_type row) { 
      return m_cont[detail::array_idx<Cols, Rows>(col, row)];
    }

    constexpr
    cref_type operator()(size_type col, size_type row) const { 
      return m_cont[detail::array_idx<Cols, Rows>(col, row)];
    }

    constexpr
    ptr_type data() noexcept {
      return m_cont.data();
    }

    /* iterators */

    constexpr 
    auto begin() noexcept {
      return m_cont.begin();
    }

    constexpr 
    auto end() noexcept {
      return m_cont.begin() + size();
    }

    constexpr 
    auto begin() const noexcept {
      return m_cont.begin();
    }

    constexpr 
    auto end() const noexcept {
      return m_cont.begin() + size();
    }

    /* misc */

    constexpr std::string to_string() const {
      std::stringstream ss;
      ss << "[ ";
      for (size_type i = 0; i < size() - 1; ++i)
        ss << operator[](i) << ", ";
      ss << operator[](size() - 1) << " ]";
      return ss.str();
    }

    /* operators and reductions */

    met_array_import_op_add(Array);
    met_array_import_op_sub(Array);
    met_array_import_op_mul(Array);
    met_array_import_op_div(Array);
    met_array_import_op_com(Array);
    met_array_import_reduc(Array);
    met_array_import_redhv(Array);
    met_array_import_modif(Array);
  };

  template <size_t Cols, size_t Rows, template <typename, size_t> typename C>
  class ArrayMask : public Array<bool, Cols, Rows, C> {
    met_array_import_base(bool, Cols, Rows, C);

  public:
    /* masking functions */

    constexpr value_type all() const noexcept {
      return std::reduce(++base_type::begin(),
                        base_type::end(),
                        *base_type::begin(),
                        std::logical_and<>());
    }

    constexpr value_type any() const noexcept {
      return std::reduce(++base_type::begin(),
                        base_type::end(),
                        *base_type::begin(),
                        std::logical_or<>());
    }

    constexpr base_type::value_type none() const noexcept {
      return !any();
    }

    template <typename Ty>
    constexpr Ty select(const Ty &a, const Ty &b) const noexcept {
      Ty c;
      for (size_type i = 0; i < base_type::reserved_size(); ++i)
        c[i] = base_type::operator[](i) ? a[i] : b[i];
      return c;
    }

    template <typename Ty>
    friend constexpr Ty select(const ArrayMask &mask, const Ty &a, const Ty &b) noexcept {
      return mask.select(a, b);
    }

    /* operators and reductions */

    met_array_import_op_com(ArrayMask);
  };

  /* Vector specializations of array types */
  
  template <typename T, size_t Size, 
            template <typename, size_t> typename C = std::array>
  using Vector = Array<T, Size, 1, C>;
  
  template <size_t Size, 
            template <typename, size_t> typename C = std::array>
  using VectorMask = ArrayMask<Size, 1, C>;
} // namespace met