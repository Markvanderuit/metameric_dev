#include <catch2/catch_test_macros.hpp>
#include <metameric/core/detail/packing.hpp>
#include <metameric/core/constraints.hpp>
#include <metameric/core/matching.hpp>
#include <metameric/core/math.hpp>
#include <metameric/core/moments.hpp>
#include <metameric/core/ranges.hpp>
#include <metameric/core/distribution.hpp>
#include <metameric/core/moments.hpp>
#include <metameric/core/metamer.hpp>
#include <metameric/core/spectrum.hpp>
#include <metameric/core/moments.hpp>
#include <metameric/core/distribution.hpp>
#include <metameric/core/json.hpp>
#include <metameric/core/io.hpp>
#include <metameric/core/utility.hpp>
#include <metameric/core/image.hpp>
#include <metameric/core/detail/packing.hpp>
#include <metameric/components/schedule.hpp>
#include <metameric/components/misc/task_frame_begin.hpp>
#include <metameric/components/misc/task_frame_end.hpp>
#include <metameric/components/views/task_window.hpp>
#include <metameric/components/views/detail/imgui.hpp>
#include <metameric/components/views/detail/task_viewport.hpp>
#include <metameric/components/views/detail/task_arcball_input.hpp>
#include <small_gl/window.hpp>
#include <small_gl/program.hpp>
#include <small_gl/buffer.hpp>
#include <small_gl/array.hpp>
#include <small_gl/dispatch.hpp>
#include <small_gl/utility.hpp>
#include <oneapi/tbb/concurrent_vector.h>
#include <algorithm>
#include <execution>
#include <sstream>
#include <vector>
#include <zstr.hpp>

using namespace met;

constexpr static uint n_boundary_samples = 128;
constexpr static uint n_interior_samples = 1024;

static fs::path input_base_path  = "C:/Users/markv/Documents/Drive/TU Delft/Projects/Spectral uplifting/Figures/multiple_reflectance_recovery";
static fs::path output_base_path = "C:/Users/markv/Documents/Drive/TU Delft/Projects/Indirect uplifting/Figures/spectral color roundtrip/results";
static std::string scene_name = "leaf";

// Scenes to run and what illuminants to generate outputs for
static auto scenes = { "leaf", "stone", "textile", "wood" };
static auto illuminants = { "D65", "FL11", "LED-RGB1" };

// Type of output to generate; default is color-mapped
constexpr static bool generate_mse = false; // If true, outputs mse of spectral distribution instead

// Which outputs to generate
constexpr static bool generate_tssl = true; // Fit spectral texture using the tessellation with interior samples, then roundtrip to color system
constexpr static bool generate_mese = false; // Fit spectral texture using the bounded MESE, then roundtrip to color system
constexpr static bool generate_csys = false; // Map spectral texture into color system

// Hack illuminant getter
Spec get_illuminant_by_name(const std::string &str) {
  if (str == "D65")           return models::emitter_cie_d65;
  else if (str == "E")        return models::emitter_cie_e;
  else if (str == "FL2")      return models::emitter_cie_fl2;
  else if (str == "FL11")     return models::emitter_cie_fl11;
  else if (str == "LED-B1")   return models::emitter_cie_ledb1;
  else if (str == "LED-RGB1") return models::emitter_cie_ledrgb1;
  return Spec(0);
}

// Quick hack-together 2d spectral distribution that easily converst to met::Image
struct SpectralImage {
public: // Constructors
  SpectralImage() = default;

  SpectralImage(const eig::Array2u &size, Spec fill = 0.f)
  : m_size(size), m_data(size.prod(), fill) { }

public: // Accessors
  auto        size() const { return m_size; }
  auto       &data()       { return m_data; }
  const auto &data() const { return m_data; }

  void set(const eig::Array2u &xy, Spec v) {
    uint i = xy.y() * m_size.x() + xy.x();
    m_data[i] = v;
  }

  const Spec &get(const eig::Array2u &xy, Spec v) const {
    uint i = xy.y() * m_size.x() + xy.x();
    return m_data[i];
  }

  Spec &get(const eig::Array2u &xy, Spec v) {
    uint i = xy.y() * m_size.x() + xy.x();
    return m_data[i];
  }

public: // Colorimetry
  Image apply(const ColrSystem &csys) {
    Image image = {{ .pixel_frmt = Image::PixelFormat::eRGBA,
                     .pixel_type = Image::PixelType::eFloat,
                     .size       = m_size }};
    std::transform(std::execution::par_unseq, range_iter(data()), image.data<eig::Array4f>().begin(),
      [&csys](const Spec &s) { return (eig::Array4f() << csys(s), 1).finished(); });
    return image;
  }

private:
  eig::Array2u      m_size;
  std::vector<Spec> m_data;
};

SpectralImage load_raw_spectral_texture(fs::path path) {
  path.make_preferred();

  // File contents
  float wvl_min, wvl_max;
  eig::Array3u dims;
  std::vector<float> block;
  {
    // Open file stream to binary spectral texture
    zstr::ifstream ifs(path.string(), std::ios::in | std::ios::binary);
    
    // Read small header data
    ifs.read((char *) &wvl_min,    sizeof(float));
    ifs.read((char *) &wvl_max,    sizeof(float));
    ifs.read((char *) dims.data(), sizeof(decltype(dims)));
    
    // Read large block data
    block.resize(dims.prod());
    ifs.read((char *) block.data(), block.size() * sizeof(float));
    ifs.close();
  }
  
  fmt::print("Read RAW spectral data: {} ({}-{} nm, {} samples)\n", dims.tail<2>(), wvl_min, wvl_max, dims.x());
  
  // Distance between wavelength samples
  float sample_dist = (wvl_max - wvl_min) / static_cast<float>(dims.x());

  // Wavelength sample locations
  std::vector<float> sample_wvls;
  sample_wvls.reserve(dims.x());
  sample_wvls.push_back(wvl_min);
  for (uint j = 1; j < dims.x(); ++j)
    sample_wvls.push_back(sample_wvls.back() + sample_dist);

  // Assemble spectral image, accumulating samples into metameric's distribution
  SpectralImage image(dims.tail<2>());
  #pragma omp parallel for
  for (int i = 0; i < dims.tail<2>().prod(); ++i) {
    image.data()[i] = io::spectrum_from_data(
      sample_wvls,
      std::span<float>(block.data() + i * dims.x(), dims.x())
    );
  }
  
  return image;
}

TEST_CASE("tssl") {
  guard(generate_tssl);

  // Load spectral basis
  // Normalize if they not already normalized
  auto basis = io::load_basis("resources/misc/basis_262144.txt");
  for (auto col : basis.func.colwise()) {
    auto min_coeff = col.minCoeff(), max_coeff = col.maxCoeff();
    col /= std::max(std::abs(max_coeff), std::abs(min_coeff));
  }

  // Define the color system in which the uplifting tessellation is defined
  ColrSystem csys = { .cmfs = models::cmfs_cie_xyz, .illuminant = models::emitter_cie_d65 };

  for (const auto &scene_name : scenes) {
    fs::path inpt_path = input_base_path / "textures_raw" / std::format("{}.sraw", scene_name);
    
    // Load hyperspectral data into metameric's format
    auto inpt_image = load_raw_spectral_texture(inpt_path);

    // Color version of hyperspectral in uplifting's color system
    auto colr_image  = inpt_image.apply(csys);

    // Generate random samples on the input size of the hyperspectral image
    UniformSampler sampler(0.f, static_cast<float>(inpt_image.data().size() - 1), 4u);
    std::vector<float> interior_samples(n_interior_samples);
    for (uint i = 0; i < n_interior_samples; ++i)
      interior_samples[i] = sampler.next_1d();

    // Sample coeffs for the tessellation's boundary from the object color solid
    auto coeffs = generate_color_system_ocs_coeffs({ .direct_objective = csys,
                                                     .basis            = basis,
                                                     .seed             = 4,
                                                     .n_samples        = n_boundary_samples });
    
    // Sample coeffs for the tessellation's interior from the hyperspectral
    {
      std::vector<Basis::vec_type> interior_coeffs(n_interior_samples);
      // #pragma omp parallel for
      for (int i = 0; i < n_interior_samples; ++i) {
        uint j = static_cast<uint>(std::round(interior_samples[i]));
        interior_coeffs[i] = generate_spectrum_coeffs(SpectrumCoeffsInfo {
          .spec = inpt_image.data().at(j), .basis = basis
        });
      }
      coeffs.append_range(interior_coeffs);
    }

    // Map coefficients to color positions in the R3 space of the tessellation
    std::vector<Colr> positions(coeffs.size());
    std::transform(std::execution::par_unseq, 
                    range_iter(coeffs), 
                    positions.begin(), 
                    [&](const auto &coef) { return csys(basis(coef)); });

    // Generate tessellation; we now essentially have all data
    // necessary for uplifting
    ConvexHull chull = ConvexHull::build(positions);

    // Now we can start rendering images under different illuminants
    for (const auto &illuminant_name : illuminants) {
      fs::path   oupt_path  = output_base_path / "tssl" / std::format("{}_{}_{}.exr", scene_name, illuminant_name, n_interior_samples);
      ColrSystem oupt_csys  = { .cmfs = models::cmfs_cie_xyz, .illuminant = get_illuminant_by_name(illuminant_name) };
      Image      oupt_image = {{ .pixel_frmt = Image::PixelFormat::eRGBA,
                                 .pixel_type = Image::PixelType::eFloat,
                                 .size       = inpt_image.size() }};

      // We now do a roundtrip
      std::transform(std::execution::par_unseq,
                     range_iter(colr_image.data<eig::Array4f>()), 
                     oupt_image.data<eig::Array4f>().begin(),
                     [&](const eig::Array4f &colr) {
        // Find enclosing simplex in tessellation
        auto [bary, elem] = chull.find_enclosing_elem(colr.head<3>().eval());
        auto simplex      = elem | index_into_view(coeffs) | rng::to<std::vector>();
        
        // Linear combination reconstructs coefficients representing some metamer in this pixel
        auto coef =(bary[0] * simplex[0] + bary[1] * simplex[1]
                  + bary[2] * simplex[2] + bary[3] * simplex[3]).cwiseMax(-1.f).cwiseMin(1.f).eval();
        
        // Uplift to spectrum, then match color under specified illuminant
        return (eig::Array4f() << oupt_csys(basis(coef)), 1).finished();
      });

      // Save output
      oupt_image.save_exr(oupt_path);
    }
  }
}

TEST_CASE("mese") {
  guard(generate_mese);

  for (const auto &scene_name : scenes) {
    fs::path inpt_path = input_base_path / "textures_raw" / std::format("{}.sraw", scene_name);
    
    // Load hyperspectral data into metameric's format
    auto inpt_image = load_raw_spectral_texture(inpt_path);
    
    // Now we can start rendering images under different illuminants
    for (const auto &illuminant_name : illuminants) {
      fs::path   oupt_path  = output_base_path / "mese" / std::format("{}_{}.exr", scene_name, illuminant_name);
      ColrSystem oupt_csys  = { .cmfs = models::cmfs_cie_xyz, .illuminant = get_illuminant_by_name(illuminant_name) };
      Image      oupt_image = {{ .pixel_frmt = Image::PixelFormat::eRGBA,
                                 .pixel_type = Image::PixelType::eFloat,
                                 .size       = inpt_image.size() }};

      // We now do a roundtrip
      std::transform(std::execution::par_unseq,
                     range_iter(inpt_image.data()), 
                     oupt_image.data<eig::Array4f>().begin(),
                     [&](const Spec &spec) {
        auto moments = spectrum_to_moments(spec);
        return (eig::Array4f() << oupt_csys(moments_to_spectrum(moments)), 1).finished();
      });

      // Save output
      oupt_image.save_exr(oupt_path);
    }
  }
}

TEST_CASE("csys") {
  guard(generate_csys);

  for (const auto &scene_name : scenes) {
    fs::path inpt_path = input_base_path / "textures_raw" / std::format("{}.sraw", scene_name);

    // Load hyperspectral data into metameric's format
    auto inpt_image = load_raw_spectral_texture(inpt_path);

    // Now we can start rendering images under different illuminants
    for (const auto &illuminant_name : illuminants) {
      fs::path   oupt_path = output_base_path / "csys" / std::format("{}_{}.exr", scene_name, illuminant_name);
      ColrSystem oupt_csys = { .cmfs = models::cmfs_cie_xyz, .illuminant = get_illuminant_by_name(illuminant_name) };
      inpt_image.apply(oupt_csys).save_exr(oupt_path);
    }
  }
}