#include <metameric/components/pipeline/task_gen_ocs.hpp>
#include <metameric/core/detail/trace.hpp>
#include <metameric/core/math.hpp>
#include <metameric/core/linprog.hpp>
#include <metameric/core/metamer.hpp>
#include <metameric/core/pca.hpp>
#include <metameric/core/spectrum.hpp>
#include <metameric/core/state.hpp>
#include <small_gl/buffer.hpp>
#include <small_gl/utility.hpp>
#include <omp.h>
#include <algorithm>
#include <execution>
#include <numbers>
#include <random>
#include <ranges>
#include <unordered_map>

namespace met {
  // Nr. of samples for OCS generation
  constexpr uint n_samples = 128;

  namespace detail {
    // Constants for gaussian cdf
    static constexpr float gaussian_epsilon   = .0001f;
    static constexpr float gaussian_alpha     = 1.f;
    static constexpr float gaussian_alpha_inv = 1.f / gaussian_alpha;
    static constexpr float gaussian_k         = 2.f / (std::numbers::pi_v<float> * gaussian_alpha);

    // Given a random vector in R3 bounded to [-1, 1], return a vector
    // distributed over a gaussian distribution
    template <uint N>
    eig::Array<float, N, 1> inv_gaussian_cdf(const eig::Array<float, N, 1> &x) {
      using ArrayNf = eig::Array<float, N, 1>;
      met_trace();

      auto y = (ArrayNf(1.f) - x * x).max(gaussian_epsilon).log().eval();
      auto z = (ArrayNf(gaussian_k) + 0.5f * y).eval();
      return (((z * z - y * gaussian_alpha_inv).sqrt() - z).sqrt() * x.sign()).eval();
    }
    
    // Given a random vector in R3 bounded to [-1, 1], return a uniformly
    // distributed point on the unit sphere
    template <uint N>
    eig::Array<float, N, 1> inv_unit_sphere_cdf(const eig::Array<float, N, 1> &x) {
      met_trace();
      return inv_gaussian_cdf<N>(x).matrix().normalized().eval();
    }

    template <uint N>
    std::vector<eig::Array<float, N, 1>> generate_unit_dirs(uint n_samples) {
      using ArrayNf = eig::Array<float, N, 1>;
      met_trace();

      // Generate separate seeds for each thread's rng
      std::random_device rd;
      using SeedTy = std::random_device::result_type;
      std::vector<SeedTy> seeds(omp_get_max_threads());
      for (auto &s : seeds) s = rd();

      std::vector<ArrayNf> unit_dirs(n_samples);
      #pragma omp parallel
      {
        // Initialize separate random number generator per thread
        std::mt19937 eng(seeds[omp_get_thread_num()]);
        std::uniform_real_distribution<float> distr(-1.f, 1.f);

        // Draw samples for this thread's range
        #pragma omp for
        for (int i = 0; i < unit_dirs.size(); ++i) {
          ArrayNf v;
          for (auto &f : v) f = distr(eng);

          unit_dirs[i] = detail::inv_unit_sphere_cdf<N>(v);
        }
      }

      return unit_dirs;
    }
  } // namespace detail
  
  GenOCSTask::GenOCSTask(const std::string &name)
  : detail::AbstractTask(name) { }

  void GenOCSTask::init(detail::TaskInitInfo &info) {
    met_trace_full();

    // Generate reused 6d samples and a uv sphere mesh for faster OCS hull generation
    m_sphere_mesh = generate_unit_sphere<eig::AlArray3f>();
    m_sphere_samples = detail::generate_unit_dirs<6>(n_samples);

    // Register ocs buffers
    constexpr auto create_flags = gl::BufferCreateFlags::eStorageDynamic;
    info.emplace_resource<gl::Buffer>("ocs_verts", { 
      .size = sizeof(eig::AlArray3f) * m_sphere_mesh.vertices.size(), .flags = create_flags });
    info.emplace_resource<gl::Buffer>("ocs_elems", { 
      .size = sizeof(eig::Array3u) * m_sphere_mesh.elements.size(), .flags = create_flags });
    info.emplace_resource<gl::Buffer>("ocs_buffer", { 
      .size = sizeof(eig::AlArray3f) * m_sphere_samples.size(), .flags = create_flags });
    info.insert_resource<Colr>("ocs_centr", Colr(0.f));
    
    // Set last accessed gamut to "none"
    m_gamut_idx = -1;
  }

  void GenOCSTask::eval(detail::TaskEvalInfo &info) {
    met_trace_full();

    // Verify that a gamut point is selected before continuing
    auto &e_gamut_idx  = info.get_resource<int>("viewport", "gamut_selection");
    guard(e_gamut_idx >= 0);

    // Get some shared resources
    auto &e_app_data      = info.get_resource<ApplicationData>(global_key, "app_data");
    auto &e_gamut_mapp_i  = e_app_data.project_data.gamut_mapp_i[e_gamut_idx];
    auto &e_gamut_mapp_j  = e_app_data.project_data.gamut_mapp_j[e_gamut_idx];

    // Verify relevant gamut state changes before continuing
    auto &e_state_gamut_colr_i = info.get_resource<std::array<CacheState, 4>>("project_state", "gamut_colr_i")[e_gamut_idx];
    auto &e_state_gamut_mapp_i = info.get_resource<std::array<CacheState, 4>>("project_state", "gamut_mapp_i")[e_gamut_idx];
    auto &e_state_gamut_mapp_j = info.get_resource<std::array<CacheState, 4>>("project_state", "gamut_mapp_j")[e_gamut_idx];
    auto &e_state_gamut_spec   = info.get_resource<std::array<CacheState, 4>>("project_state", "gamut_spec")[e_gamut_idx];
    auto &e_state_mappings     = info.get_resource<std::vector<CacheState>>("project_state", "mappings");
    guard(m_gamut_idx != e_gamut_idx || e_state_gamut_colr_i == CacheState::eStale || 
          e_state_gamut_mapp_i == CacheState::eStale || e_state_gamut_mapp_j == CacheState::eStale ||
          e_state_mappings[e_gamut_mapp_i] == CacheState::eStale || e_state_mappings[e_gamut_mapp_j] == CacheState::eStale);

    // Cache last accessed gamut idx
    m_gamut_idx = e_gamut_idx;

    // Get rest of shared resources
    auto &i_ocs_buffer    = info.get_resource<gl::Buffer>("ocs_buffer");
    auto &i_ocs_verts     = info.get_resource<gl::Buffer>("ocs_verts");
    auto &i_ocs_elems     = info.get_resource<gl::Buffer>("ocs_elems");
    auto &i_ocs_center    = info.get_resource<Colr>("ocs_centr");
    auto &e_basis         = info.get_resource<BMatrixType>(global_key, "pca_basis");
    auto &e_gamut_colr_i  = e_app_data.project_data.gamut_colr_i[e_gamut_idx];
    auto &e_gamut_offs_j  = e_app_data.project_data.gamut_offs_j[e_gamut_idx];
    auto &e_gamut_spec    = e_app_data.project_data.gamut_spec[e_gamut_idx];

    // Generate color system spectra
    CMFS cmfs_i = e_app_data.loaded_mappings[e_gamut_mapp_i].finalize(e_gamut_spec);
    CMFS cmfs_j = e_app_data.loaded_mappings[e_gamut_mapp_j].finalize(e_gamut_spec);

    // Generate metamer set convex hull 
    auto basis  = e_basis.rightCols(wavelength_bases);
    auto points = generate_boundary(e_basis.rightCols(wavelength_bases), cmfs_i, cmfs_j, e_gamut_colr_i, m_sphere_samples);
    auto ocs_points = std::vector<AlColr>(range_iter(points));
    auto ocs_hull   = generate_convex_hull<eig::AlArray3f>(m_sphere_mesh, ocs_points);

    // Compute center of object color solid
    i_ocs_center = std::reduce(std::execution::par_unseq, range_iter(ocs_hull.vertices), 
      eig::AlArray3f(0.f), [](const auto &a, const auto &b) { return (a + b).eval(); })
                  / static_cast<float>(ocs_hull.vertices.size());

    // Update buffer data
    i_ocs_buffer.set(cnt_span<const std::byte>(ocs_points));
    i_ocs_verts.set(cnt_span<const std::byte>(ocs_hull.vertices));
    i_ocs_elems.set(cnt_span<const std::byte>(ocs_hull.elements));

    // Reset gamut offset to ocs center
    e_gamut_offs_j = i_ocs_center - e_gamut_colr_i;
  }
}