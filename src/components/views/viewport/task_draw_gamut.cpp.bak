#include <metameric/core/data.hpp>
#include <metameric/core/spectrum.hpp>
#include <metameric/core/state.hpp>
#include <metameric/core/texture.hpp>
#include <metameric/core/utility.hpp>
#include <metameric/core/detail/trace.hpp>
#include <metameric/components/views/viewport/task_draw_gamut.hpp>
#include <metameric/components/views/detail/imgui.hpp>
#include <metameric/components/views/detail/arcball.hpp>
#include <small_gl/framebuffer.hpp>
#include <small_gl/texture.hpp>
#include <small_gl/utility.hpp>

namespace met {
  // Size/opacity settings for vertex/element selection
  constexpr float vert_deslct_size = 0.005f;
  constexpr float vert_select_size = 0.01f;
  constexpr float vert_msover_size = 0.015f;
  constexpr float elem_deslct_opac = 0.05f;
  constexpr float elem_select_opac = 0.1f;
  constexpr float elem_msover_opac = 0.2f;

  // Buffer flags for flushable, persistent, write-only mapping
  constexpr auto buffer_create_flags = gl::BufferCreateFlags::eMapWrite | gl::BufferCreateFlags::eMapPersistent;
  constexpr auto buffer_access_flags = gl::BufferAccessFlags::eMapWrite | gl::BufferAccessFlags::eMapPersistent | gl::BufferAccessFlags::eMapFlush;

  constexpr uint max_vert_support = mvc_weights;
  constexpr uint max_elem_support = 2 * mvc_weights;

  ViewportDrawGamutTask::ViewportDrawGamutTask(const std::string &name)
  : detail::AbstractTask(name, true) { }

  void ViewportDrawGamutTask::init(detail::TaskInfo &info) {
    met_trace_full();
    
    // Get shared resources
    auto &e_appl_data = info.get_resource<ApplicationData>(global_key, "app_data");
    auto &e_proj_data = e_appl_data.project_data;

    // Setup sizes/opacities buffers and instantiate relevant mappings
    std::vector<float> vert_input_sizes(max_vert_support, vert_deslct_size);
    std::vector<float> elem_input_opacs(max_elem_support, elem_deslct_opac);
    m_vert_size_buffer = {{ .data = cnt_span<const std::byte>(vert_input_sizes), .flags = buffer_create_flags }};
    m_elem_opac_buffer = {{ .data = cnt_span<const std::byte>(elem_input_opacs), .flags = buffer_create_flags }};
    m_vert_size_map = cast_span<float>(m_vert_size_buffer.map(buffer_access_flags));
    m_elem_opac_map = cast_span<float>(m_elem_opac_buffer.map(buffer_access_flags));

    // Setup shared uniform buffer object
    m_unif_buffer = {{ .size = sizeof(UniformBuffer), .flags = buffer_create_flags }};
    m_unif_map    = m_unif_buffer.map_as<UniformBuffer>(buffer_access_flags).data();

    // Setup data buffers
    m_vert_buffer = {{ .size = sizeof(eig::Array4f) * max_vert_support, .flags = buffer_create_flags }};
    m_elem_buffer = {{ .size = sizeof(eig::Array3u) * max_elem_support, .flags = buffer_create_flags }};
    m_vert_map    = m_vert_buffer.map_as<eig::AlArray3f>(buffer_access_flags);
    m_elem_map    = m_elem_buffer.map_as<eig::Array3u>(buffer_access_flags);

    // Setup array objects for (A) instanced quad draw (B) mesh line draw (C) mesh face draw
    m_vert_array = {{ }};
    m_elem_array = {{ 
      .buffers  = {{ .buffer = &m_vert_buffer,  .index = 0, .stride = sizeof(eig::AlArray3f) }},
      .attribs  = {{ .attrib_index = 0, .buffer_index = 0, .size = gl::VertexAttribSize::e3 }},
      .elements = &m_elem_buffer
    }};

    // Setup dispatch objects summarizing both draw operations
    m_vert_draw = {
      .type             = gl::PrimitiveType::eTriangles,
      .vertex_count     = 3 * static_cast<uint>(e_proj_data.vertices.size()),
      .capabilities     = {{ gl::DrawCapability::eMSAA, false }},
      .draw_op          = gl::DrawOp::eFill,
      .bindable_array   = &m_vert_array,
      .bindable_program = &m_vert_program
    };
    m_edge_draw = { 
      .type             = gl::PrimitiveType::eTriangles,
      .vertex_count     = 3 * static_cast<uint>(e_proj_data.gamut_elems.size()),
      .capabilities     = {{ gl::DrawCapability::eCullOp, false }},
      .draw_op          = gl::DrawOp::eLine,
      .bindable_array   = &m_elem_array,
      .bindable_program = &m_edge_program 
    };
    m_elem_draw = { 
      .type             = gl::PrimitiveType::eTriangles,
      .vertex_count     = 3 * static_cast<uint>(e_proj_data.gamut_elems.size()),
      .draw_op          = gl::DrawOp::eFill,
      .bindable_array   = &m_elem_array,
      .bindable_program = &m_elem_program 
    };
      
    // Load shader program objects
    m_vert_program = {{ .type = gl::ShaderType::eVertex,   .path = "resources/shaders/viewport/draw_gamut_vert.vert" },
                      { .type = gl::ShaderType::eFragment, .path = "resources/shaders/viewport/draw_gamut_vert.frag" }};
    m_edge_program = {{ .type = gl::ShaderType::eVertex,   .path = "resources/shaders/viewport/draw_gamut_elem.vert" },
                      { .type = gl::ShaderType::eFragment, .path = "resources/shaders/viewport/draw_gamut_elem.frag" }};
    m_elem_program = {{ .type = gl::ShaderType::eVertex,   .path = "resources/shaders/viewport/draw_gamut_elem.vert" },
                      { .type = gl::ShaderType::eFragment, .path = "resources/shaders/viewport/draw_gamut_elem.frag" }};

    eig::Array4f clear_colr = e_appl_data.color_mode == ApplicationData::ColorMode::eDark
                            ? eig::Array4f { 1, 1, 1, 1 }
                            : eig::Array4f { 0, 0, 0, 1 };

    // Set non-changing uniform values
    m_edge_program.uniform("u_value_offs",         .0f);
    m_edge_program.uniform("u_use_opacity",      false);
    m_elem_program.uniform("u_value_offs",         .0f);
    m_elem_program.uniform("u_use_opacity",       true);
    m_vert_program.uniform("u_value",       clear_colr);
  }

  void ViewportDrawGamutTask::dstr(detail::TaskInfo &info) {
    met_trace_full();

    if (m_vert_size_buffer.is_init() && m_vert_size_buffer.is_mapped()) m_vert_size_buffer.unmap();
    if (m_elem_opac_buffer.is_init() && m_elem_opac_buffer.is_mapped()) m_elem_opac_buffer.unmap();
  }

  void ViewportDrawGamutTask::eval(detail::TaskInfo &info) {
    met_trace_full();
                                
    // Get shared resources 
    auto &e_appl_data  = info.get_resource<ApplicationData>(global_key, "app_data");
    auto &e_proj_data  = e_appl_data.project_data;
    auto &e_arcball    = info.get_resource<detail::Arcball>("viewport.input", "arcball");
    auto &e_pipe_state = info.get_resource<ProjectState>("state", "pipeline_state");
    auto &e_view_state = info.get_resource<ViewportState>("state", "viewport_state");

    // Stream specific mesh data if in any way changed
    if (e_pipe_state.any_verts || e_pipe_state.any_elems) {
      for (uint i = 0; i < e_pipe_state.verts.size(); ++i) {
        guard_continue(e_pipe_state.verts[i].colr_i);
        m_vert_map[i] = e_proj_data.vertices[i].colr_i;
        m_vert_buffer.flush(sizeof(eig::Array3f), i * sizeof(eig::AlArray3f));
      }
      for (uint i = 0; i < e_pipe_state.elems.size(); ++i) {
        guard_continue(e_pipe_state.elems[i]);
        m_elem_map[i] = e_proj_data.gamut_elems[i];
        m_elem_buffer.flush(sizeof(eig::Array3u), i * sizeof(eig::Array3u));
      }
      m_vert_draw.vertex_count = 3 * static_cast<uint>(e_proj_data.vertices.size());
      m_edge_draw.vertex_count = 3 * static_cast<uint>(e_proj_data.gamut_elems.size());
      m_elem_draw.vertex_count = 3 * static_cast<uint>(e_proj_data.gamut_elems.size());
    }

    // Stream size data based on selected vertices, if a state change occurred
    if (e_view_state.vert_selection || e_view_state.vert_mouseover) {
      auto &e_vert_select = info.get_resource<std::vector<uint>>("viewport.input.vert", "selection");
      auto &e_vert_msover = info.get_resource<std::vector<uint>>("viewport.input.vert", "mouseover");

      std::ranges::fill(m_vert_size_map, vert_deslct_size);
      std::ranges::for_each(e_vert_msover, [&](uint i) { m_vert_size_map[i] = vert_msover_size; });
      std::ranges::for_each(e_vert_select, [&](uint i) { m_vert_size_map[i] = vert_select_size; });
      m_vert_size_buffer.flush();
    }

    // Stream opacity data based on selected elements, if a state change occurred
    if (e_view_state.elem_selection || e_view_state.elem_mouseover) {
      auto &e_elem_select = info.get_resource<std::vector<uint>>("viewport_input_elem", "selection");
      auto &e_elem_msover = info.get_resource<std::vector<uint>>("viewport_input_elem", "mouseover");

      std::ranges::fill(m_elem_opac_map, elem_deslct_opac);
      std::ranges::for_each(e_elem_msover, [&](uint i) { m_elem_opac_map[i] = elem_msover_opac; });
      std::ranges::for_each(e_elem_select, [&](uint i) { m_elem_opac_map[i] = elem_select_opac; });
      m_elem_opac_buffer.flush();
    }
    
    // Stream camera data to uniform, if a state change occurred
    if (e_view_state.camera_matrix || e_view_state.camera_aspect) {
      m_unif_map->camera_matrix = e_arcball.full().matrix();
      m_unif_map->camera_aspect = { 1.f, e_arcball.m_aspect };
      m_unif_buffer.flush();
    }

    // Set OpenGL state shared between coming draw operations
    auto shared_capabilities = { gl::state::ScopedSet(gl::DrawCapability::eDepthTest, false),
                                 gl::state::ScopedSet(gl::DrawCapability::eBlendOp,    true),
                                 gl::state::ScopedSet(gl::DrawCapability::eCullOp,     true),
                                 gl::state::ScopedSet(gl::DrawCapability::eMSAA,       true) };
    
    // Bind buffers to relevant buffer targets
    m_unif_buffer.bind_to(gl::BufferTargetType::eUniform,            0);
    m_vert_buffer.bind_to(gl::BufferTargetType::eShaderStorage,      0);
    m_elem_opac_buffer.bind_to(gl::BufferTargetType::eShaderStorage, 1);
    m_vert_size_buffer.bind_to(gl::BufferTargetType::eShaderStorage, 2);

    // Dispatch draw calls
    gl::dispatch_draw(m_elem_draw);
    gl::dispatch_draw(m_edge_draw);
    gl::dispatch_draw(m_vert_draw);
  }
} // namespace met