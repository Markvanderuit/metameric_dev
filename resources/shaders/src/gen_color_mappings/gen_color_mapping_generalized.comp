#version 460 core

// Enable necessary subgroup extensions
#extension GL_KHR_shader_subgroup_basic      : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_clustered  : require

#include <guard.glsl>
#include <bary.glsl>

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std140)             uniform;
layout(std430)             buffer;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_bary { Bary4 data[]; } bary_in;
layout(binding = 1) restrict readonly  buffer b_vert { vec3  data[]; } vert_in;
layout(binding = 2) restrict readonly  buffer b_elem { uvec3 data[]; } elem_in; // unused
layout(binding = 3) restrict writeonly buffer b_colr { vec3  data[]; } colr_out;

// Uniform buffer declarations
layout(binding = 0) uniform b_unif {
  uint n;
  uint n_verts;
  uint n_elems;
} unif;

// Shared memory declarations
shared vec3 s_verts_in[generalized_weights];

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < unif.n_verts; i += gl_WorkGroupSize.x)
    s_verts_in[i] = vert_in.data[i];
  memoryBarrierShared();
  barrier();
}

const uint sg_cluster_size = generalized_weights / 4; // so 4 then

void main() {
  load_shared();

  const uint i = gl_GlobalInvocationID.x / sg_cluster_size; // 000011112222
  const uint j = gl_GlobalInvocationID.x % sg_cluster_size; // 012301230123

  guard(i < unif.n);

  // Output color is convex combination of gamut vertices
  vec4 w = bary_in.data[i][j];
  vec3 v = vec3(0);
  for (uint k = 0; k < 4; ++k)
    v += w[k] * s_verts_in[j * 4 + k];
  v = subgroupClusteredAdd(v, sg_cluster_size);

  if (j == 0)
    colr_out.data[i] = v;
}