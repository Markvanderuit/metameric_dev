#version 460 core

#include <guard.glsl>
#include <math.glsl>

layout(local_size_x = 256) in;
layout(std140)             uniform;
layout(std430)             buffer;

layout(binding = 0) restrict readonly  buffer b_0 { vec4  data[]; } b_bary_in;
layout(binding = 1) restrict readonly  buffer b_1 { vec3  data[]; } b_vert_in;
layout(binding = 2) restrict readonly  buffer b_2 { uvec4 data[]; } b_elem_in;
layout(binding = 3) restrict writeonly buffer b_3 { vec3  data[]; } b_colr_out;

// Uniform buffer declarations
layout(binding = 0) uniform u_0 {
  uint n;
  uint n_verts;
  uint n_elems;
} b_unif;

// Constants
const uint max_verts = 256;
const uint max_elems = 256;

shared vec3  s_verts_in[max_verts];
shared uvec4 s_elems_in[max_elems];

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_verts; i += gl_WorkGroupSize.x)
    s_verts_in[i] = b_vert_in.data[i];
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_elems; i += gl_WorkGroupSize.x)
    s_elems_in[i] = b_elem_in.data[i];
  
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();
  
  const uint i = gl_GlobalInvocationID.x;
  guard(i < b_unif.n);

  uvec4 elem = s_elems_in[floatBitsToUint(b_bary_in.data[i].w)];
  vec4 bary  = vec4(b_bary_in.data[i].xyz, 1.f - hsum(b_bary_in.data[i].xyz));

  vec3 v = vec3(0);
  for (uint j = 0; j < 4; ++j)
    v += bary[j] * s_verts_in[elem[j]];

  b_colr_out.data[i] = v;
}