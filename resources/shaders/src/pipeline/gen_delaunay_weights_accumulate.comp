#include <preamble.glsl>
#include <guard.glsl>
#include <math.glsl>

extension(GL_KHR_shader_subgroup_ballot,    require)
extension(GL_KHR_shader_subgroup_clustered, require)
extension(GL_KHR_shader_subgroup_shuffle,   require)

// Delaunay search tree; node data structure
struct Node { 
  vec3 minb; // Bounding volume maximum
  uint i;    // Begin index of underlying range
  vec3 maxb; // Bounding volume minimum
  uint n;    // Extent of underlying range
};

// Unit of work data assigned by the shader for the next task
struct WorkUnit {
  uint elem_i; // Index of the mesh tree node to be compared
  uint colr_i; // Index of the color tree node to be compared
};

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly buffer b_elem { Node data[]; } elem_in;
layout(binding = 1) restrict readonly buffer b_colr { Node data[]; } colr_in;
layout(binding = 2) restrict readonly buffer b_ordr { uint data[]; } ordr_in;
layout(binding = 3) restrict readonly buffer b_work {
  uint     head;   // Atomic head count
  uint    _pad[3]; // 3x4by padding
  WorkUnit data[]; // Actual work data
} work_in;
layout(binding = 4) restrict coherent buffer b_flag { uint data[]; } flag_inout;

// Uniform buffer declarations
layout(binding = 0) uniform b_unif {
  uint elem_begin_lvl;
  uint colr_begin_lvl;
  uint n_elems;
} unif_in;

// Shared memory declarations
shared uint s_work_head_in;

void load_shared() {
  if (gl_LocalInvocationID.x == 0)
    s_work_head_in = work_in.head;
  
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();

  const uint i = gl_GlobalInvocationID.x / gl_SubgroupSize;
  guard(i < s_work_head_in);

  // Load current work and relevant hierarchy nodes
  WorkUnit work = work_in.data[i];
  if (subgroupElect())
    work = work_in.data[i];  
  work.elem_i = subgroupBroadcastFirst(work.elem_i);
  work.colr_i = subgroupBroadcastFirst(work.colr_i);

  // A current node is shared among a subgroup cluster, which is the degree of the tree (8)
  Node colr;
  if (subgroupElect()) 
    colr = colr_in.data[work.colr_i];
  colr.i = subgroupBroadcastFirst(colr.i);
  colr.n = subgroupBroadcastFirst(colr.n);

  // Assemble (just one bit of) flag data
  uint flag_i = work.elem_i % 32;
  uint flag_j = work.elem_i < 32 ? 0 : 1;
  uint flag_half = 1u << flag_i;

  // Store flag results for relevant color signals; grid-stride loop per subgroup cluster
  for (uint colr_i = colr.i + gl_SubgroupInvocationID;
            colr_i < colr.i + colr.n;
            colr_i += gl_SubgroupSize) {
    uint colr_i_ordr = ordr_in.data[colr_i];
    atomicOr(flag_inout.data[2 * colr_i_ordr + flag_j], flag_half);
  } // for colr_i
}