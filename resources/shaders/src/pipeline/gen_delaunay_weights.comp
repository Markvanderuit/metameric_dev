#version 460 core

#include <guard.glsl>
#include <math.glsl>
#include <tree.glsl>

// Delaunay search tree; node data structure
struct Node { 
  vec3 maxb; // Bounding volume minimum
  uint i;    // Begin index of underlying range
  vec3 minb; // Bounding volume maximum
  uint n;    // Extent of underlying range
};

// Wrapper data packing tetrahedron data [x, y, z, w]; 64 bytes under std430
struct Elem {
  mat3 inv; // Inverse of 3x3 matrix [x - w, y - w, z - w]
  vec3 sub; // Subtractive component w
};

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
// layout(binding = 3) restrict readonly  buffer b_tree { Node  data[]; } node_in;
layout(binding = 0) restrict readonly  buffer b_posi { vec3 data[]; } posi_in;
layout(binding = 1) restrict readonly  buffer b_pack { Elem data[]; } pack_in;
layout(binding = 2) restrict writeonly buffer b_bary { vec4 data[]; } bary_out;

// Uniform buffer declarations
layout(binding = 0) uniform b_unif {
  uint n;
  uint n_verts;
  uint n_elems;
  uint n_nodes;
} unif_in;

// Shared memory declarations
shared Elem s_pack_in[512];
// shared Node  s_nodes_in[max_node_support]; // Shared load of node_in buffer

void load_shared() {
  // for (uint i = gl_LocalInvocationID.x; i < unif_in.n_nodes; i += gl_WorkGroupSize.x)
  //   s_nodes_in[i] = node_in.data[i];
  for (uint i = gl_LocalInvocationID.x; i < unif_in.n_elems; i += gl_WorkGroupSize.x)
    s_pack_in[i] = pack_in.data[i];
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();
  
  const uint i = gl_GlobalInvocationID.x;
  guard(i < unif_in.n);
  
  vec3 p = posi_in.data[i];
  
  float result_err = FLT_MAX;
  vec4 result_bary;
  uint result_indx;

  for (uint j = 0; j < unif_in.n_elems; ++j) {
    // Compute barycentric weights using packed element data
    vec3 xyz = s_pack_in[j].inv * (p - s_pack_in[j].sub);
    vec4 bary = vec4(xyz, 1.f - hsum(xyz));

    // Compute squared error of potentially negative barycentric weights
    // float err = dot(bary, clamp(bary, 0, 1));
    vec4 err4 = bary - clamp(bary, 0, 1); //  abs(dot(bary, clamp(bary, 0, 1)));
    float err = sdot(err4);

    // Store best result if error is improved
    guard_continue(err < result_err);
    result_err  = err;
    result_bary = bary;
    result_indx = j;
  }

  // Store result, packing 3/4th of weights, together with the tetrahedron's index
  bary_out.data[i] = vec4(result_bary.xyz, uintBitsToFloat(result_indx));
}