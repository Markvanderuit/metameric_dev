#include <preamble.glsl>
#include <render/detail/scene_types.glsl>
#include <math.glsl>
#include <moments.glsl>

// Wrapper data packing tetrahedron data [x, y, z, w]; 64 bytes under std430
struct Elem {
  mat3 inv; // Inverse of 3x3 matrix [x - w, y - w, z - w]
  vec3 sub; // Subtractive component w
};

// General layout rule declarations
layout(local_size_x = 16, local_size_y = 16) in;
layout(std430) buffer;
layout(std140) uniform;

// Specialization constant declarations
layout(constant_id = 0) const bool sample_albedo = true;

// Storage buffer declarations
layout(binding = 0) restrict readonly buffer b_buff_textures {
  TextureInfo[] data;
} buff_textures;
layout(binding = 1) restrict readonly buffer b_buff_weights {
  AtlasLayout data[];
} buff_weights;
/* layout(binding = 2) restrict readonly buffer b_buff_uplift_pack { 
  Elem data[]; 
} buff_uplift_pack; */

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_unif {
  uint  object_i;
  uvec2 dispatch_n;
} unif;
layout(binding = 1) uniform b_buff_uplift_data {
  uint offs;
  uint size;
} buff_uplift_data;
layout(binding = 2) uniform b_buff_objects {
  uint n;
  ObjectInfo data[32];
} buff_objects;
layout(binding = 3) uniform b_buff_uplift_pack { 
  Elem data[met_max_constraints]; 
} buff_uplift_pack;

// Image/sampler declarations
layout(binding = 0)          uniform                    sampler2DArray b_txtr_3f;
layout(binding = 0, rgba32f) uniform restrict writeonly image2DArray   b_bary_4f;

vec3 fetch_texel(in ObjectInfo object_info, in uvec2 tx_in) {
  // We select color/texture at compile-time and compile
  // two versions of this shader, to avoid awkward warnings
  // when there is an unbound sampler object floating around
  if (sample_albedo) {
    // Color value is supplied by scene texture
    TextureInfo info = buff_textures.data[object_info.albedo_i];
    uvec2 tx = info.offs + min(tx_in, info.size - 1);
    return vec3(texelFetch(b_txtr_3f, ivec3(tx, info.layer), 0));
  } else {
    // Color value is specified directly
    return object_info.albedo_v;
  }
}

void store_weight(in AtlasLayout info, in uvec2 tx_in, in vec4 bary) {
  uvec2 tx = info.offs + min(tx_in, info.size - 1);
  imageStore(b_bary_4f, ivec3(tx, info.layer), bary);
}

// Shared memory declarations
shared Elem s_pack_in[256];

void load_shared() {
  for (uint i = gl_LocalInvocationID.x;  i < buff_uplift_data.size; i += gl_WorkGroupSize.x)
    s_pack_in[i] = buff_uplift_pack.data[i];
  memoryBarrierShared();
  barrier();
}

void main() {
  // Load relevant object/uplifting/atlas data
  AtlasLayout bary_layout = buff_weights.data[unif.object_i];
  ObjectInfo  object_info = buff_objects.data[unif.object_i];

  // Cram pack data into shared memory
  load_shared();

  // Cut off unused invocations
  const uvec2 i = gl_GlobalInvocationID.xy;
  guard(all(lessThan(i, unif.dispatch_n)));

  // Fetch the current texel
  const vec3 p = fetch_texel(object_info, i).xyz;

  float result_err = FLT_MAX;
  vec4 result_bary;
  uint result_indx;

  for (uint j = 0; j < buff_uplift_data.size; ++j) {
    // Compute barycentric weights using packed element data
    vec3 xyz = s_pack_in[j].inv * (p - s_pack_in[j].sub);
    vec4 bary = vec4(xyz, 1.f - hsum(xyz));

    // Compute squared error of potentially unbounded barycentric weights
    float err = sdot(bary - clamp(bary, 0, 1));

    // Store better result if error is improved
    guard_continue(err < result_err);
    result_err  = err;
    result_bary = bary;
    result_indx = j + buff_uplift_data.offs;
  } // for (uint j)

  // Store result, packing 3/4th of weights, together with the tetrahedron's index
  store_weight(bary_layout, i, vec4(result_bary.xyz, float(result_indx)));
}