#version 460 core

#include <guard.glsl>
#include <math.glsl>

// Wrapper data packing tetrahedron data [x, y, z, w]; 64 bytes under std430
struct Elem {
  mat3 inv; // Inverse of 3x3 matrix [x - w, y - w, z - w]
  vec3 sub; // Subtractive component w
};

// Delaunay search tree; node data structure
struct Node { 
  vec3 minb; // Bounding volume maximum
  uint i;    // Begin index of underlying range
  vec3 maxb; // Bounding volume minimum
  uint n;    // Extent of underlying range
};

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_posi { vec3  data[]; } posi_in;
layout(binding = 1) restrict readonly  buffer b_pack { Elem  data[]; } pack_in;
layout(binding = 2) restrict readonly  buffer b_elem { Node  data[]; } elem_in;
layout(binding = 3) restrict readonly  buffer b_refr { uint  data[]; } refr_in;
layout(binding = 4) restrict readonly  buffer b_ordr { uint  data[]; } ordr_in;
layout(binding = 5) restrict readonly  buffer b_flag { uvec2 data[]; } flag_in;
layout(binding = 6) restrict writeonly buffer b_bary { vec4  data[]; } bary_out;

// Uniform buffer declarations
layout(binding = 0) uniform b_unif {
  uint n;
  uint n_verts;
  uint n_elems;
} unif_in;

// Shared memory declarations
shared Elem s_pack_in[512];

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < unif_in.n_elems; i += gl_WorkGroupSize.x)
    s_pack_in[i] = pack_in.data[i];
  
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();

  const uint i = gl_GlobalInvocationID.x;
  guard(i < unif_in.n);

  // Get flagged work for this color's containing node
  uvec2 flag = flag_in.data[refr_in.data[i]];

  // uvec2 flag = flag_in.data[i];
  vec3 colr = posi_in.data[i];
  
  vec4 bary_i = vec4(0);
  float bary_i_err = FLT_MAX;

  // Fallback; this node was accidentally entirely culled during traversal
  // if (flag == uvec2(0))
  //   flag = uvec2(0xFFFFFFFF);

  while (flag != uvec2(0)) {
    // Obtain next index through most significant 1-bit in flag
    uint flag_j = flag.x != 0 ? 0 : 1;
    uint flag_i = findMSB(flag[flag_j]);

    // Query the relevant tree node
    Node elem = elem_in.data[flag_i + flag_j * 32];

    // Iterate relevant delaunay elements
    for (uint elem_i = elem.i;
              elem_i < elem.i + elem.n && bary_i_err != -1; 
              elem_i += 1) {
      uint elem_i_ordr = ordr_in.data[elem_i];

      // Compute barycentric weights using packed element data
      vec3 xyz = s_pack_in[elem_i_ordr].inv * (colr - s_pack_in[elem_i_ordr].sub);
      vec4 bary_j = vec4(xyz, 1.f - hsum(xyz));
      
      // Compute squared error of potentially negative barycentric weights,
      // and get an integer representation in here
      float bary_j_err = hsum(abs(bary_j - clamp(bary_j, 0, 1)));

      // Compare and update results
      if (bary_j_err < bary_i_err) {
        bary_i_err = bary_j_err;
        bary_i = vec4(xyz, uintBitsToFloat(elem_i_ordr)); //  Pack 3 weights with the element's index
      }
    }

    // Unflag the visited 1-bit
    flag[flag_j] &= ~(1u << flag_i);
  }

  // Store result to buffer
  bary_out.data[i] = bary_i;
}