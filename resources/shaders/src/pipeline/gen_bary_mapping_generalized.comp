#include <preamble.glsl>
#include <bary.glsl>
#include <color.glsl>

// Enable necessary subgroup extensions
extension(GL_KHR_shader_subgroup_basic, require)
extension(GL_KHR_shader_subgroup_clustered, require)

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std140)             uniform;
layout(std430)             buffer;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly buffer b_bary { Bary4 data[]; } bary_in;
layout(binding = 1) restrict readonly buffer b_vert { vec3  data[]; } vert_in;
layout(binding = 2) restrict readonly buffer b_elem { uvec4 data[]; } elem_in; // unused
layout(binding = 3) restrict readonly buffer b_colr { vec3  data[]; } colr_in;
layout(binding = 0, rgba32f) restrict writeonly uniform image2D i_colr;

// Constants
const uint max_verts_support = 1024;
const uint max_elems_support = 1024;

// Uniform buffer declarations
layout(binding = 0) uniform b_unif {
  uvec2 size_in;
  uvec2 size_out;
  uint  n_verts;
  uint  n_elems;
  uint  selection[max_verts_support];
} unif_in;

// Shared memory declarations
shared vec3 s_verts_in[generalized_weights];

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < unif_in.n_verts; i += gl_WorkGroupSize.x)
    s_verts_in[i] = vert_in.data[i];
  memoryBarrierShared();
  barrier();
}

const uint sg_cluster_size = generalized_weights / 4; // so 4 then

void main() {
  load_shared();
  
  // Find 1d/2d coordinates in output size
  const uint i_out = gl_GlobalInvocationID.x / sg_cluster_size; // 000011112222
  const uvec2 ij_out = uvec2(i_out % unif_in.size_out.x, i_out / unif_in.size_out.x);

  guard(all(lessThan(ij_out, unif_in.size_out)));

  // Nearest-neighbor find corresponding 2d/1d coordinates in input size
  const uvec2 ij_in = uvec2(((vec2(ij_out) + 0.5f) / vec2(unif_in.size_out)) * vec2(unif_in.size_in));
  const uint i_in = unif_in.size_in.x * ij_in.y + ij_in.x;
  const uint j_in = gl_GlobalInvocationID.x % sg_cluster_size; // 012301230123

  // // Output color is convex combination of gamut vertices
  // vec3 w = (j < unif.n_verts && unif.selection[j] != 0) 
  //         ? vert_in.data[j_in] * bary_in.data[i_in][j_in / 4][j_in % 4] 
  //         : vec3(0);

  // vec3 w = (j < unif.n_verts && unif.selection[j] != 0) 
  //         ? vert_in.data[j] * bary_in.data[i][j / 4][j % 4] 
  //         : vec3(0);
  // vec3 s = subgroupClusteredAdd(w, sg_cluster_size); // / b_bsum_in.data[i];

  vec4 w = bary_in.data[i_in][j_in];
  vec3 v = vec3(0);
  for (uint k = 0; k < 4; ++k)
    v += float(unif_in.selection[j_in * 4 + k]) * w[k] * s_verts_in[j_in * 4 + k];
  v = subgroupClusteredAdd(v, sg_cluster_size);

  if (j_in == 0)
    imageStore(i_colr, ivec2(ij_out), vec4(lrgb_to_srgb(v), 1));
}