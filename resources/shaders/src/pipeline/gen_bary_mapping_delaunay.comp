#include <preamble.glsl>
#include <guard.glsl>
#include <color.glsl>
#include <math.glsl>

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std140)             uniform;
layout(std430)             buffer;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly buffer b_bary { vec4  data[]; } bary_in;
layout(binding = 1) restrict readonly buffer b_vert { vec3  data[]; } vert_in;
layout(binding = 2) restrict readonly buffer b_elem { uvec4 data[]; } elem_in;
layout(binding = 3) restrict readonly buffer b_colr { vec3 data[];  } colr_in;
layout(binding = 0, rgba32f) restrict writeonly uniform image2D i_colr;

// Constants
const uint max_verts_support = 1024;
const uint max_elems_support = 1024;

// Uniform buffer declarations
layout(binding = 0) uniform b_unif {
  uvec2 size_in;
  uvec2 size_out;
  uint  n_verts;
  uint  n_elems;
  uint  selection[max_verts_support];
} unif_in;

// Shared memory declarations
shared vec3  s_verts_in[max_verts_support]; // Shared load of vert_in buffer
shared uvec4 s_elems_in[max_elems_support]; // Shared load of elem_in buffer

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < unif_in.n_verts; i += gl_WorkGroupSize.x)
    s_verts_in[i] = vert_in.data[i];
  for (uint i = gl_LocalInvocationID.x; i < unif_in.n_elems; i += gl_WorkGroupSize.x)
    s_elems_in[i] = elem_in.data[i];
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();
  
  // Find 1d/2d coordinates in output size
  const uint i_out = gl_GlobalInvocationID.x;
  const uvec2 ij_out = uvec2(i_out % unif_in.size_out.x, i_out / unif_in.size_out.x);

  guard(all(lessThan(ij_out, unif_in.size_out)));

  // Nearest-neighbor find corresponding 2d/1d coordinates in input size
  uvec2 ij_in = uvec2(((vec2(ij_out) + 0.5f) / vec2(unif_in.size_out)) * vec2(unif_in.size_in));
  uint i_in = unif_in.size_in.x * ij_in.y + ij_in.x;
    
  // Load relevant barycentric weights and vertex indices
  uvec4 idx = s_elems_in[floatBitsToUint(bary_in.data[i_in].w)];
  vec3 xyz  = bary_in.data[i_in].xyz;
  vec4 bary = vec4(xyz, 1.f - hsum(xyz));

  // Compute convex combination of vertex colors, negating unselected vertices
  vec3 v = vec3(0);
  for (uint j = 0; j < 4; ++j)
    v += float(unif_in.selection[idx[j]]) * bary[j] * s_verts_in[idx[j]];

  // Store results to image/buffer
  imageStore(i_colr, ivec2(ij_out), vec4(lrgb_to_srgb(v), 1));
}