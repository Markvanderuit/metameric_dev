#include <preamble.glsl>
#include <guard.glsl>
#include <math.glsl>

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_bary { vec4  data[]; } bary_in;
layout(binding = 1) restrict readonly  buffer b_vert { vec3  data[]; } vert_in;
layout(binding = 2) restrict readonly  buffer b_elem { uvec4 data[]; } elem_in;
layout(binding = 3) restrict writeonly buffer b_colr { vec3  data[]; } colr_out;

// Constants
const uint max_verts_support = 1024;
const uint max_elems_support = 1024;

// Uniform buffer declarations
layout(binding = 0) uniform b_unif {
  uint n;
  uint n_verts;
  uint n_elems;
  uint selection[max_verts_support];
} unif;

// Shared memory declarations
shared vec3  s_verts_in[max_verts_support]; // Shared load of vert_in buffer
shared uvec4 s_elems_in[max_elems_support]; // Shared load of elem_in buffer

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < unif.n_verts; i += gl_WorkGroupSize.x)
    s_verts_in[i] = vert_in.data[i];
  for (uint i = gl_LocalInvocationID.x; i < unif.n_elems; i += gl_WorkGroupSize.x)
    s_elems_in[i] = elem_in.data[i];
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();
  
  const uint i = gl_GlobalInvocationID.x;
  guard(i < unif.n);

  // Load relevant barycentric weights and vertex indices
  uvec4 idx = s_elems_in[floatBitsToUint(bary_in.data[i].w)];
  vec3 xyz  = bary_in.data[i].xyz;
  vec4 bary = vec4(xyz, 1.f - hsum(xyz));

  // Compute convex combination of vertex colors, negating unselected vertices
  vec3 v = vec3(0);
  for (uint j = 0; j < 4; ++j)
    v += float(unif.selection[idx[j]]) * bary[j] * s_verts_in[idx[j]];

  colr_out.data[i] = v;
}