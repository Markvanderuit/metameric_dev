#version 460 core

#include <guard.glsl>
#include <math.glsl>
#include <random_uniform.glsl>
#include <scene.glsl>
#include <spectrum.glsl>

// General layout rule declarations
layout(local_size_x = 16, local_size_y = 16) in;
layout(std140) uniform;
layout(std430) buffer;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_unif {
  mat4  trf;
  mat4  inv;
  uvec2 viewport_size;
} buff_unif;
layout(binding = 1) uniform b_buff_sampler {
  uint iter;
  uint n_iters_per_dispatch;
} buff_sampler;

// Storage buffer declarations
layout(binding = 0) restrict writeonly buffer b_buff_state {
  uvec2 data[];
} buff_state;
layout(binding = 1) restrict readonly buffer b_buff_objects {
  ObjectInfo[] data;
} buff_objects;
layout(binding = 2) restrict readonly buffer b_buff_textures {
  TextureInfo[] data;
} buff_textures;
layout(binding = 3) restrict readonly buffer b_buff_uplifts {
  UpliftInfo data[];
} buff_uplifts;


// Texture unit, ergo asampler declarations
layout(binding = 0) uniform sampler2D      b_gbuffer_norm_dp; // G-buffer pack 0; normals, frag depth
layout(binding = 1) uniform sampler2D      b_gbuffer_txc_idx; // G-buffer pack 1; txcoords, object idx
layout(binding = 2) uniform sampler2DArray b_txtr_1f;         // Alpha texture atlas
layout(binding = 3) uniform sampler2DArray b_txtr_3f;         // RGB texture atlas
layout(binding = 4) uniform sampler2DArray b_uplf_4f;         // Uplifting weight atlas
layout(binding = 5) uniform sampler1DArray b_spec_4f;         // Uplifting spectral atlas
layout(binding = 6) uniform sampler1DArray b_illm_1f;         // Illuminant function data, 1 component
layout(binding = 7) uniform sampler1DArray b_cmfs_3f;         // Observer function data, 3 components
layout(binding = 8) uniform sampler1DArray b_csys_3f;         // Color system spectra, 3 components

// Image unit, output declaration
layout(binding = 0, rgba32f) uniform restrict image2D b_target_4f;

// Simple G-Buffer struct
struct GBuffer {
  vec3 p;        // World-space position, recovered from depth
  vec3 n;        // World-space normals
  vec2 tx;       // Surface texture coordinates
  uint object_i; // UINT_MAX if no object is visible, and the object's index otherwise
};

GBuffer sample_gbuffer(in vec2 xy) {
  vec4 p0 = texture(b_gbuffer_norm_dp, xy);
  vec4 p1 = texture(b_gbuffer_txc_idx, xy);

  // Early out if no object is visible
  if (p1.w != FLT_MAX)
    return GBuffer(vec3(0), vec3(0), vec2(0), UINT_MAX);

  // Recover world-space position from depth
  vec4 invp = buff_unif.inv * vec4(vec3(xy, p0.w) * 2.f - 1.f, 1);
  vec3 p    = invp.xyz / invp.w;

  // Recover object index from packed data
  uint object_i = floatBitsToUint(p1.z);

  // Return valid sample
  return GBuffer(p, p0.xyz, p1.xy, object_i);
}

vec3 sample_colsys(in uint colsys_i, in float wvl) {
  return texture(b_csys_3f, vec2(wvl, colsys_i)).xyz;
}

vec4 sample_uplift_bary(in ObjectInfo object_info, in vec2 tx_in) {
  // Query nearest-neigbor barycentric weight for this object
  // TODO sample bilinearly!
  uvec2 tx  = object_info.offs + uvec2(vec2(object_info.size) * mod(tx_in, 1.f));
  return texelFetch(b_uplf_4f, ivec3(tx, object_info.layer), 0);
}

float sample_uplift_refl(in UpliftInfo uplift_info, in vec4 bary, in float wvl) {
  // Extract tesselation index from packing, and replace with correct weight w
  uint elem_i = floatBitsToUint(bary.w) + uplift_info.elem_offs;
  bary.w = 1.f - hsum(bary.xyz);
  
  // Recover recovered surface reflectance for given wavelength as a dot product
  return dot(bary, texture(b_spec_4f, vec2(wvl, elem_i)));
}

/* float sample_uplift(in ObjectInfo object_info, in UpliftInfo uplift_info, in vec2 tx_in, in float wvl) {
  // Query nearest-neigbor barycentric weight for this object
  // TODO sample bilinearly!
  uvec2 tx  = object_info.offs + uvec2(vec2(object_info.size) * mod(tx_in, 1.f));
  vec4 bary = texelFetch(b_uplf_4f, ivec3(tx, object_info.layer), 0);

  // Extract tesselation index from packing, and replace with correct weight w
  uint elem_i = floatBitsToUint(bary.w) + uplift_info.elem_offs;
  bary.w = 1.f - hsum(bary.xyz);

  // Recover recovered surface reflectance for given wavelength as a dot product
  return dot(bary, texture(b_spec_4f, vec2(wvl, elem_i)));
} */

void main() {
  // 2D/1D image/buffer coordinates
  const uvec2 i = gl_GlobalInvocationID.xy;
  const uint  j = i.y * buff_unif.viewport_size.x + i.x;
  guard(all(lessThan(i, buff_unif.viewport_size)));

  // Initialize sampler state, or load it if the frame is cumulative
  uvec3 state = uvec3(i, 0);
  if (buff_sampler.iter != 0)
    state  = uvec3(buff_state.data[j], buff_sampler.iter);

  // Compute viewspace coordinates and sample g-buffer
  vec2    xy = (vec2(i) + 0.5) / vec2(buff_unif.viewport_size);
  GBuffer gb = sample_gbuffer(xy);

  // If no object is visible, set to black and early-out
  if (gb.object_i == UINT_MAX) {
    imageStore(b_target_4f, ivec2(i), vec4(0, 0, 0, 1));
    return;
  }

  // Load relevant info objects
  ObjectInfo object_info = buff_objects.data[gb.object_i];
  UpliftInfo uplift_info = buff_uplifts.data[object_info.uplifting_i];

  // Initialize image value, or load it if the frame is cumulative
  vec3 value = vec3(0);
  if (buff_sampler.iter != 0)
    value = imageLoad(b_target_4f, ivec2(i)).xyz * float(buff_sampler.iter);

  // Take direct light samples
  vec4 bary   = sample_uplift_bary(object_info, gb.tx);
  for (uint i = 0; i < buff_sampler.n_iters_per_dispatch; ++i) {
    float wvl = next_1d(state); // Sample next wavelength
    
    // Sample surface reflectance and color system spectra at wavelength
    float r = sample_uplift_refl(uplift_info, bary, wvl);
    vec3 csys = sample_colsys(0, wvl);

    // Add to direct lighting    
    value += csys * r * float(wavelength_samples);
  } // for (uint i)

  // Reweight image value by nr. of samples
  value /= float(buff_sampler.iter + buff_sampler.n_iters_per_dispatch);

  // Store updated image value and sampler state
  imageStore(b_target_4f, ivec2(i), vec4(value, 1));
  buff_state.data[j] = state.xy;
}