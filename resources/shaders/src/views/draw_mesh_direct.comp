#version 460 core

#include <guard.glsl>
#include <gbuffer.glsl>
#include <math.glsl>
#include <random_uniform.glsl>
#include <scene.glsl>
#include <spectrum.glsl>

// General layout rule declarations
layout(local_size_x = 16, local_size_y = 16) in;
layout(std140) uniform;
layout(std430) buffer;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_unif {
  mat4  trf;
  mat4  inv;
  uvec2 viewport_size;
} buff_unif;
layout(binding = 1) uniform b_buff_sampler {
  uint iter;
  uint n_iters_per_dispatch;
} buff_sampler;

// Storage buffer declarations
layout(binding = 0) restrict writeonly buffer b_buff_state {
  uvec2 data[];
} buff_state;
layout(binding = 1) restrict readonly buffer b_buff_objects {
  ObjectInfo[] data;
} buff_objects;
layout(binding = 2) restrict readonly buffer b_buff_textures {
  TextureInfo[] data;
} buff_textures;
layout(binding = 3) restrict readonly buffer b_buff_uplifts {
  UpliftInfo data[];
} buff_uplifts;

// Texture unit, ergo sampler declarations
layout(binding = 0) uniform sampler2D      b_gbuffer; // G-buffer pack
layout(binding = 1) uniform sampler2DArray b_txtr_1f; // Alpha texture atlas
layout(binding = 2) uniform sampler2DArray b_txtr_3f; // RGB texture atlas
layout(binding = 3) uniform sampler2DArray b_uplf_4f; // Uplifting weight atlas
layout(binding = 4) uniform sampler1DArray b_spec_4f; // Uplifting spectral atlas
layout(binding = 5) uniform sampler1DArray b_illm_1f; // Illuminant function data, 1 component
layout(binding = 6) uniform sampler1DArray b_cmfs_3f; // Observer function data, 3 components
layout(binding = 7) uniform sampler1DArray b_csys_3f; // Color system spectra, 3 components

// Image unit, output declaration
layout(binding = 0, rgba32f) uniform restrict image2D b_target_4f;

GBuffer sample_gbuffer(in vec2 xy) {
  uvec4 pack = floatBitsToUint(texture(b_gbuffer, xy));
  return decode_gbuffer(pack, xy, buff_unif.inv);
}

vec3 sample_colsys(in uint colsys_i, in float wvl) {
  return texture(b_csys_3f, vec2(wvl, colsys_i)).xyz;
}

uvec4 sample_uplift_bary_indices(in ObjectInfo object_info, in vec2 tx_in) {
  // Query nearest-neigbor barycentric weight for this object
  vec2 tx = (vec2(object_info.offs) + vec2(object_info.size) * tx_in) / textureSize(b_uplf_4f, 0).xy;
  return uvec4(textureGather(b_uplf_4f, vec3(tx, object_info.layer), 3)); // fourth channel is non-variant :D
}

float sample_uplift_refl(in UpliftInfo uplift_info, in vec4 bary, in float wvl) {
  // Extract tesselation index from packing, and replace with correct weight w
  uint elem_i = uint(bary.w) + uplift_info.elem_offs;
  bary.w = 1.f - hsum(bary.xyz);
  
  // Recover recovered surface reflectance for given wavelength as a dot product
  return dot(bary, texture(b_spec_4f, vec2(wvl, elem_i)));
}

vec3 fetch_color_part(inout uvec3 state, in ObjectInfo object_info, in UpliftInfo uplift_info, in uvec2 tx) {
  vec3 value = vec3(0);
  
  // Element indices differ, so sample weights separately
  vec4 bary = texelFetch(b_uplf_4f, ivec3(tx, object_info.layer), 0);
  
  // Take direct light samples
  for (uint i = 0; i < buff_sampler.n_iters_per_dispatch; ++i) {
    // Sample next wavelength
    float wvl = next_1d(state); 
    
    // Evaluate surface reflectance and color system spectra at wavelength,
    // then add to direct lighting estiamte
    float r = sample_uplift_refl(uplift_info, bary, wvl);
    vec3 csys = sample_colsys(0, wvl); // TODO should be observer?

    // Apply result
    value += csys * r * float(wavelength_samples);
  } // for (uint i)

  return value;
}

vec3 fetch_color(inout uvec3 state, in ObjectInfo object_info, in UpliftInfo uplift_info, in vec2 tx) {
  const uvec2 texel_offsets[4] = uvec2[4](uvec2(0, 0), uvec2(1, 0), uvec2(0, 1), uvec2(1, 1));

  vec2  tx_full  = vec2(object_info.offs) + vec2(object_info.size) * tx - vec2(0.5f);
  uvec2 tx_floor = uvec2(tx_full);
  vec2  alpha    = mod(tx_full, 1.f);

  vec3[4] values;
  uvec3   state_;
  for (uint i = 0; i < 4; ++i) {
    state_ = state;
    values[i] = fetch_color_part(state_, object_info, uplift_info, tx_floor + texel_offsets[i]);
  }
  state = state_;

  return mix(mix(values[0], values[1], alpha.x), mix(values[2], values[3], alpha.x), alpha.y);
}

vec3 sample_color(inout uvec3 state, in ObjectInfo object_info, in UpliftInfo uplift_info, in vec2 tx) {
  vec3 value = vec3(0);

  // All element indices are the same, so sample barycentric weights directly
  // TODO add uv components to uniform buffer
  vec2 tx_bary = (vec2(object_info.offs) + vec2(object_info.size) * tx) / textureSize(b_uplf_4f, 0).xy;
  vec4 bary = textureLod(b_uplf_4f, vec3(tx_bary, object_info.layer), 0);
  
  // Take direct light samples
  for (uint i = 0; i < buff_sampler.n_iters_per_dispatch; ++i) {
    // Sample next wavelength
    float wvl = next_1d(state); 
    
    // Evaluate surface reflectance and color system spectra at wavelength,
    // then add to direct lighting estiamte
    float r = sample_uplift_refl(uplift_info, bary, wvl);
    vec3 csys = sample_colsys(0, wvl); // TODO should be observer?

    value += csys * r;
  } // for (uint i)

  return value * float(wavelength_samples);
}

void main() {
  // 2D/1D image/buffer coordinates
  const uvec2 i = gl_GlobalInvocationID.xy;
  const uint  j = i.y * buff_unif.viewport_size.x + i.x;
  guard(all(lessThan(i, buff_unif.viewport_size)));

  // Initialize sampler state, or load it if the frame is cumulative
  uvec3 state = uvec3(i, 0);
  if (buff_sampler.iter != 0)
    state  = uvec3(buff_state.data[j], buff_sampler.iter);

  // Compute viewspace coordinates and sample g-buffer
  vec2    xy = (vec2(i) + 0.5) / vec2(buff_unif.viewport_size);
  GBuffer gb = sample_gbuffer(xy);

  // If no object is visible, set to black and early-out
  if (gb.object_i == UINT_MAX) {
    imageStore(b_target_4f, ivec2(i), vec4(0, 0, 0, 1));
    return;
  }

  // Load relevant info objects
  ObjectInfo object_info = buff_objects.data[gb.object_i];
  UpliftInfo uplift_info = buff_uplifts.data[object_info.uplifting_i];

  // Initialize image value, or load it if the frame is cumulative
  vec3 value = vec3(0);
  if (buff_sampler.iter != 0)
    value = imageLoad(b_target_4f, ivec2(i)).xyz * float(buff_sampler.iter);

  uvec4 indices = sample_uplift_bary_indices(object_info, gb.tx);
  if (all(equal(indices, uvec4(indices.x)))) {
    // Hot path; all element indices are the same
    value += sample_color(state, object_info, uplift_info, gb.tx);
  } else {
    // Cold path; border region, indices differ, manually combine samples
    value += fetch_color(state, object_info, uplift_info, gb.tx);
  }

  // Reweight image value by actual nr. of samples
  value /= float(buff_sampler.iter + buff_sampler.n_iters_per_dispatch);
  // value = vec3(gb.tx, 0); // /= float(buff_sampler.iter + buff_sampler.n_iters_per_dispatch);

  // Store updated image value and sampler state
  imageStore(b_target_4f, ivec2(i), vec4(value, 1));
  buff_state.data[j] = state.xy;
}