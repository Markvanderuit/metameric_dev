#include <preamble.glsl>
#include <guard.glsl>
#include <math.glsl>
#include <random_uniform.glsl>

// General layout rule declarations
layout(local_size_x = 16, local_size_y = 16) in;
layout(std140) uniform;
layout(std430) buffer;

// Shader storage declaration
layout(binding = 0) restrict buffer b_state { uvec2 data[]; } state_buffer;

// Uniform declarations
layout(binding = 0) uniform b_unif {
  uvec2 dims;
  uint  iter;
  uint  n_iters;
} unif_in;
layout(binding = 1, rgba32f) restrict uniform image2D i_target;

void main() {  
  // const uvec2 i = gl_GlobalInvocationID.xy;
  // const uint  j = i.y * unif_in.dims.x + i.x;
  // guard(all(lessThan(i, unif_in.dims)));

  // uint iter = unif_in.iter;

  // uvec3 state = uvec3(i, 0);
  // vec3 value = vec3(0);
  // if (iter != 0) {
  //   state = uvec3(state_buffer.data[j], unif_in.iter);
  //   value = imageLoad(i_target, ivec2(i)).xyz;
  // }

  // for (uint k = 0; k < unif_in.n_iters; ++k) {
  //   vec3 next = next_3d(state);
  //   if (iter == 0) {
  //     value = next;
  //   } else {
  //     value = ((value * vec3(iter)) + next) / vec3(iter + 1);
  //   }
  //   iter++;
  // } // for (uint k)

  // // Store current sampler state and result
  // state_buffer.data[j] = state.xy;
  // imageStore(i_target, ivec2(i), vec4(vec3(value), 1));
}