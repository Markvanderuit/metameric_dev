#include <preamble.glsl>
#include <math.glsl>
#include <moments.glsl>
#include <spectrum.glsl>

extension(GL_KHR_shader_subgroup_arithmetic,       require)
extension(GL_KHR_shader_subgroup_ballot,           require)
extension(GL_KHR_shader_subgroup_clustered,        require)
extension(GL_KHR_shader_subgroup_shuffle,          require)
extension(GL_KHR_shader_subgroup_shuffle_relative, require)

// General layout rule declarations
layout(local_size_x = 32) in;
layout(std140) uniform;
layout(std430) buffer;

// Shader storage declaration
layout(binding = 0) restrict readonly  buffer b_phase  { 
  float[wavelength_samples] data; 
} buff_phase;
layout(binding = 1) restrict readonly  buffer b_signal  { 
  float[wavelength_samples] data; 
} buff_signal;
layout(binding = 2) restrict writeonly buffer b_output { 
  uvec4 data;  
} buff_output;

// Some moment types are elevated to double precision
#define float_t   double
#define complex_t dvec2

// Source for cos/sin approximations:
// https://www.ganssle.com/approx.htm
// https://www.ganssle.com/approx/sincos.cpp

double cos_121s(double x) {
	double x2 = x * x;
	return   ( 0.99999999999925182 
    + x2 * (-0.49999999997024012 
    + x2 * ( 0.041666666473384543 
    + x2 * (-0.001388888418000423 
    + x2 * ( 0.0000248010406484558 
    + x2 * (-0.0000002752469638432 
    + x2 *   0.0000000019907856854))))));
}

double cos_121(double x){
	x = mod(x, 2.0 * M_PI);	            // Get rid of values > 2* pi
  x = abs(x);                         // cos(-x) = cos(x)
	int quad = int(x * 2.0 * M_PI_INV);	// Get quadrant # (0 to 3) below
	switch (quad){
    case 0: return  cos_121s(x);
    case 1: return -cos_121s(M_PI - x);
    case 2: return -cos_121s(x - M_PI);
    case 3: return  cos_121s(2.0 * M_PI - x);
	}
}

double sin_121(double x){
	return cos_121(0.5 * M_PI - x);
}

complex_t complex_mult(complex_t lhs, complex_t rhs) {
  return complex_t(lhs.x * rhs.x - lhs.y * rhs.y,
                   lhs.x * rhs.y + lhs.y * rhs.x);
}

// Moment coefficients are stored in shared memory
shared complex_t s_coeffs[moment_coeffs];

void eval(in float phase,  in float phase_next, 
          in float signal, in float signal_next, 
          in bool  mask) {
  if (phase >= phase_next)
    mask = false;

  float gradient = (signal_next - signal) / (phase_next - phase);      
  float y_inscpt = signal - gradient * phase;
  
  for (uint j = 1; j < moment_coeffs; ++j) {
    float rcp_j2 = 1.f / float(j * j);
    float flt_j  = float(j);
 
    vec2 common_summands = vec2(gradient * rcp_j2, y_inscpt / flt_j);

    // Elevate to double precision from this point onward
    complex_t moment_add = complex_mult(
      common_summands + complex_t(0, gradient * flt_j * phase_next * rcp_j2 ),
      complex_t(cos_121(-flt_j * phase_next), sin_121(-flt_j * phase_next))
    );
    complex_t moment_sub = complex_mult(
      common_summands + complex_t(0, gradient * flt_j * phase * rcp_j2 ),
      complex_t(cos_121(-flt_j * phase), sin_121(-flt_j * phase))
    );

    moment_add = subgroupAdd(mask ? moment_add : vec2(0));
    moment_sub = subgroupAdd(mask ? moment_sub : vec2(0));
    
    if (subgroupElect())
      s_coeffs[j] += moment_add - moment_sub;
    memoryBarrierShared();
    barrier();
  } // for (uint j = 1)

  // j = 0
  {
    float moment_add = .5f * gradient * (phase_next * phase_next) + y_inscpt * phase_next;
    float moment_sub = .5f * gradient * (phase * phase)           + y_inscpt * phase;

    moment_add = subgroupAdd(mask ? moment_add : 0.0);
    moment_sub = subgroupAdd(mask ? moment_sub : 0.0);

    if (subgroupElect())
      s_coeffs[0] += moment_add - moment_sub;
    memoryBarrierShared();
    barrier();
  }
}

void main() {
  guard(gl_SubgroupID == 0); // One warp shader

  // Determine wavelengths and their respective indices for each thread;
  // assumes wavelength_samples == 64
  ivec2 wvls_i = ivec2(2 * gl_SubgroupInvocationID) + ivec2(0, 1); // [0, 1], [2, 3], ..., [62, 63]
  
  // Load phase and signal data for this invocation; the subgroup together
  // describes a full spectral range
  vec2 phase  = vec2(buff_phase.data[wvls_i[0]],  buff_phase.data[wvls_i[1]]);
  vec2 signal = clamp(vec2(buff_signal.data[wvls_i[0]], buff_signal.data[wvls_i[1]]), vec2(0), vec2(1)); // clamp in case mixture shits the bed, though this shouldn't happen
  
  // Set coefficients to zero
  if (gl_SubgroupInvocationID < moment_coeffs)
    s_coeffs[gl_SubgroupInvocationID] = complex_t(0);
  memoryBarrierShared();
  barrier();
  
  // Fit coefficients
  eval(-M_PI,     phase[0],      
       signal[0], signal[0], 
       gl_SubgroupInvocationID == 0);
  eval(phase[0],  phase[1], 
       signal[0], signal[1], 
       true);
  eval(phase[1],  subgroupShuffleDown(phase[0],  1), 
       signal[1], subgroupShuffleDown(signal[0], 1),
       gl_SubgroupInvocationID < gl_SubgroupSize - 1);
  eval(phase[1],  0.0,
       signal[1], signal[1],
       gl_SubgroupInvocationID == gl_SubgroupSize - 1);

  // Store packed coefficients
  if (gl_SubgroupInvocationID < moment_coeffs) {
    float coeff = float(s_coeffs[gl_SubgroupInvocationID].x * M_PI_INV);
    uint pack   = packHalf2x16(vec2(coeff, subgroupShuffleDown(coeff, 1)));

    uvec4 v = uvec4(0);
    v[gl_SubgroupInvocationID / 2] += gl_SubgroupInvocationID % 2 == 0 ? pack : 0u;
    v = subgroupAdd(v);
    
    if (subgroupElect())    
      buff_output.data = v;
  }
}