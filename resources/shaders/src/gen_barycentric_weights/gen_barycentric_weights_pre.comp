#version 460 core

// Enable necessary subgroup extensions
#extension GL_KHR_shader_subgroup_basic      : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_clustered  : require
#extension GL_EXT_shader_atomic_float        : require

#pragma optionNV(fastmath on)
#pragma optionNV(fastprecision on)

#include <guard.glsl>
#include <math.glsl>
#include <bary_cluster.glsl>

const uint n_elems_max = 24;
const uvec3 _ip = uvec3(1, 2, 0);
const uvec3 _im = uvec3(2, 0, 1);

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_0 { vec3   data[]; } b_vert_in;
layout(binding = 1) restrict readonly  buffer b_1 { uvec3  data[]; } b_elem_in;
layout(binding = 2) restrict readonly  buffer b_2 { vec3   data[]; } b_posi_in;
layout(binding = 3) restrict writeonly buffer b_3 { InBary data[]; } b_bary_out;

// Uniform buffer declarations
layout(binding = 0) uniform u_0 {
  uint n;
  uint n_verts;
  uint n_elems;
} b_size;

const uint s_bary_n = gl_WorkGroupSize.x / cl_bary_invoc_n;
      uint s_bary_i = gl_LocalInvocationID.x / cl_bary_invoc_n;

// Shared memory declarations
shared vec3   s_verts_in[barycentric_weights];
shared uvec3  s_elems_in[n_elems_max];
shared InBary s_bary_out[s_bary_n];
shared bool   s_bary_clr[s_bary_n];

void clear_bary() {
  cl_bary_iter(j) s_bary_out[s_bary_i][j] = 0.f;

  barrier();
  memoryBarrierShared();
}

void add_bary(in vec3 v, in uvec3 el) {
  s_bary_out[s_bary_i][el[0]] += v[0];
  s_bary_out[s_bary_i][el[1]] += v[1];
  s_bary_out[s_bary_i][el[2]] += v[2];
  
  barrier();
  memoryBarrierShared();
}

void store_bary(uint i) {
  for (uint j = cl_bary_invoc_offs; j < cl_bary_invoc_offs + cl_bary_invoc_size; ++j)
    b_bary_out.data[i][j] = s_bary_out[s_bary_i][j];
}

void load_shared_data() {
  const uint i = gl_LocalInvocationID.x;

  // Load mesh data into shared memory
  if (i < b_size.n_verts)
    s_verts_in[i] = b_vert_in.data[i];
  if (i < b_size.n_elems)
    s_elems_in[i] = b_elem_in.data[i];

  // Clear barycentric data
  if (cl_bin_elect())
    s_bary_clr[s_bary_i] = true;
  clear_bary();
  
  barrier();
  memoryBarrierShared();
}

vec3 shift(in vec3 v, in uvec3 i)   { return vec3(v[i[0]], v[i[1]], v[i[2]]); }

// Enum flags for per-triangle MVC computation return type
#define MVCReturnOnVertex   0x01u
#define MVCReturnOnTriangle 0x02u
#define MVCReturnOnPlane    0x04u
#define MVCReturnCorrect    0x08u

// Return result for per-triangle MVC computation
struct MVCReturnObject {
  vec3 weight;
  uint type;
};

vec3 safe_denom(vec3 denom) {
  return mix(max(denom, M_EPS), 
             min(denom, -M_EPS), 
             lessThan(sign(denom), 
             vec3(0)));
}

MVCReturnObject mvc_per_elem(in vec3 x, in uvec3 v) {
  // Compute per-vertex data
  vec3 d;
  mat3 u;
  for (uint i = 0; i < 3; ++i) {
    vec3 p = s_verts_in[v[i]];

    d[i] = length(p - x);

    // Fallback: x lies near or on vertex, return value directly
    if (d[i] <= M_EPS) {
      vec3 w = vec3(0);
      w[i] = 1;
      return MVCReturnObject(w, MVCReturnOnVertex);
    }

    u[i] = normalize(p - x);
  }
  
  // Compute spherical triangle data
  vec3 theta = 2.f * asin(.5f * vec3(length(u[1] - u[2]), length(u[2] - u[0]), length(u[0] - u[1])));
  vec3 sin_theta = sin(theta);
  float h = .5f * hsum(theta);
    
  // Fallback: x lies near or on triangle, use 2D barycentric coordinates
  if (abs(M_PI - h) <= M_EPS) {
    vec3 w = sin_theta * shift(d, _ip) * shift(d, _im);
    return MVCReturnObject(w, MVCReturnOnTriangle);
  }

  vec3 c = (2.f * sin(h) * sin(h - theta)) 
         / max(shift(sin_theta, _ip) * shift(sin_theta, _im), M_EPS) 
         - 1.f;
  vec3 s = sign(determinant(u)) * sqrt(max(1.f - c * c, M_EPS));

  // Fallback: x lies on triangle's plane but way outside triangle, ignore weights
  if (any(lessThanEqual(abs(s), vec3(M_EPS)))) {
    return MVCReturnObject(vec3(0), MVCReturnOnPlane);
  }

  // Compute actual weights as we are somewhere inside
  vec3 w = (theta - shift(c, _ip) * shift(theta, _im) - shift(c, _im) * shift(theta, _ip))
         / safe_denom(d * shift(sin_theta, _ip) * shift(s, _im));
  return MVCReturnObject(w, MVCReturnCorrect);
}

void main() {
  load_shared_data();

  const uint i = gl_GlobalInvocationID.x / cl_bary_invoc_n;
  guard(i < b_size.n);
  
  // Iterate triangle elements
  vec3 x = b_posi_in.data[i];
  for (uint j = cl_bary_invoc_i; j < b_size.n_elems; j += cl_bary_invoc_n) {
    const uvec3 el = s_elems_in[j];
    MVCReturnObject result = mvc_per_elem(x, el);
    
    // Catch special cases which return their own value directly
    if (result.type == MVCReturnOnVertex || result.type == MVCReturnOnTriangle) {
      // Tell other invocations to clear values
      s_bary_clr[s_bary_i] = false;
    }

    bool clr = s_bary_clr[s_bary_i];
    if (!clr)
      clear_bary();
    
    if ((clr || result.type == MVCReturnOnVertex || result.type == MVCReturnOnTriangle)
      && !(result.type == MVCReturnOnPlane || any(isnan(result.weight))))
      add_bary(result.weight, el);

    if (!clr)
      break;
  }

  // Store total to buffer
  store_bary(i);
}