#version 460 core

#pragma optionNV(fastmath on)
#pragma optionNV(fastprecision on)

#include <guard.glsl>
#include <math.glsl>
#include <spectrum.glsl>

const uint n_elems_max = 24;
const uvec3 _ip = uvec3(1, 2, 0);
const uvec3 _im = uvec3(2, 0, 1);

#define Bary float[barycentric_weights]

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_0 { vec3  data[]; } b_vert_in;
layout(binding = 1) restrict readonly  buffer b_1 { uvec3 data[]; } b_elem_in;
layout(binding = 2) restrict readonly  buffer b_2 { vec3  data[]; } b_posi_in;
layout(binding = 3) restrict writeonly buffer b_3 { Bary  data[]; } b_bary_out;

// Uniform buffer declarations
layout(binding = 0) uniform u_0 {
  uint n;
  uint n_verts;
  uint n_elems;
} b_size;

// Shared memory declarations
shared vec3  s_verts_in[barycentric_weights];
shared uvec3 s_elems_in[n_elems_max];

void load_shared_data() {
  const uint i = gl_LocalInvocationID.x;
  if (i < b_size.n_verts)
    s_verts_in[i] = b_vert_in.data[i];
  if (i < b_size.n_elems)
    s_elems_in[i] = b_elem_in.data[i];
  barrier();
  memoryBarrierShared();
}

// Define to perform commonly occuring iteration
#define weights_iter(__b)      for (uint __b = 0; __b < b_size.n_verts; ++__b)
#define weights_iter_full(__b) for (uint __b = 0; __b < barycentric_weights; ++__b)

Bary constr_weights(in float f) {
  Bary w;
  weights_iter_full(i) w[i] = f;
  return w;
}

void scatter_add_weights(inout Bary w, in vec3 w_, in uvec3 i) {
  w[i[0]] += w_[0];
  w[i[1]] += w_[1];
  w[i[2]] += w_[2];
}

vec3 shift(in vec3 v, in uvec3 i)   { return vec3(v[i[0]], v[i[1]], v[i[2]]); }

// Enum flags for per-triangle MVC computation return type
#define MVCReturnOnVertex   0x01u
#define MVCReturnOnTriangle 0x02u
#define MVCReturnOnPlane    0x04u
#define MVCReturnCorrect    0x08u

// Return result for per-triangle MVC computation
struct MVCReturnObject {
  vec3 weight;
  uint type;
};

vec3 safe_denom(vec3 denom) {
  return mix(max(denom, M_EPS), 
             min(denom, -M_EPS), 
             lessThan(sign(denom), 
             vec3(0)));
}

MVCReturnObject mean_value_coords_per_tri(in vec3 x, in uvec3 v) {
  // Compute per-vertex data
  vec3 d;
  mat3 u;
  for (uint i = 0; i < 3; ++i) {
    vec3 p = s_verts_in[v[i]];

    d[i] = length(p - x);

    // Fallback: x lies near or on vertex, return value directly
    if (d[i] <= M_EPS) {
      vec3 w = vec3(0);
      w[i] = 1;
      return MVCReturnObject(w, MVCReturnOnVertex);
    }

    u[i] = normalize(p - x);
  }
  
  // Compute spherical triangle data
  vec3 theta = 2.f * asin(.5f * vec3(length(u[1] - u[2]), length(u[2] - u[0]), length(u[0] - u[1])));
  vec3 sin_theta = sin(theta);
  float h = .5f * hsum(theta);
    
  // Fallback: x lies near or on triangle, use 2D barycentric coordinates
  if (abs(M_PI - h) <= M_EPS) {
    vec3 w = sin_theta * shift(d, _ip) * shift(d, _im);
    return MVCReturnObject(w, MVCReturnOnTriangle);
  }

  vec3 c = (2.f * sin(h) * sin(h - theta)) 
         / max(shift(sin_theta, _ip) * shift(sin_theta, _im), M_EPS) 
         - 1.f;
  vec3 s = sign(determinant(u)) * sqrt(max(1.f - c * c, M_EPS));

  // Fallback: x lies on triangle's plane but way outside triangle, ignore weights
  if (any(lessThanEqual(abs(s), vec3(M_EPS)))) {
    return MVCReturnObject(vec3(0), MVCReturnOnPlane);
  }

  // Compute actual weights as we are somewhere inside
  vec3 w = (theta - shift(c, _ip) * shift(theta, _im) - shift(c, _im) * shift(theta, _ip))
         / safe_denom(d * shift(sin_theta, _ip) * shift(s, _im));
  return MVCReturnObject(w, MVCReturnCorrect);
}

Bary mean_value_coords_total(in vec3 x) {
  Bary weight = constr_weights(0.f);
  // float weight_sum = 0.f;

  for (uint j = 0; j < b_size.n_elems; ++j) {
    const uvec3 v = s_elems_in[j];
    MVCReturnObject result = mean_value_coords_per_tri(x, v);
    
    // Catch special case which returns no value; also catch NANs j.i.c.
    if (result.type == MVCReturnOnPlane || any(isnan(result.weight)))
      continue;

    // Catch special cases which return their own value directly
    if (result.type == MVCReturnOnVertex || result.type == MVCReturnOnTriangle) {
      // Set other weights to 0
      weight = constr_weights(0.f);
      
      scatter_add_weights(weight, result.weight, v);
      // weight_sum = hsum(result.weight);

      break;
    }

    scatter_add_weights(weight, result.weight, v);
    // weight_sum += hsum(result.weight);
  }

  // weights_iter(i) weight[i] /= weight_sum;
  return weight;
}

void main() {
  load_shared_data();
  
  const uint i = gl_GlobalInvocationID.x;
  guard(i < b_size.n);
  b_bary_out.data[i] = mean_value_coords_total(b_posi_in.data[i]);;
}