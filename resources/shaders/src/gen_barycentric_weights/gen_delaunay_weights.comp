#version 460 core

#include <guard.glsl>
#include <math.glsl>

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_0 { vec3  data[]; } b_vert_in;
layout(binding = 1) restrict readonly  buffer b_1 { uvec4 data[]; } b_elem_in;
layout(binding = 2) restrict readonly  buffer b_2 { vec3  data[]; } b_posi_in;
layout(binding = 3) restrict writeonly buffer b_3 { vec4  data[]; } b_bary_out;

// Uniform buffer declarations
layout(binding = 0) uniform u_0 {
  uint n;
  uint n_verts;
  uint n_elems;
} b_unif;

// Constants
const uint max_verts_support = 256;
const uint max_elems_support = 256;

// Shared memory declarations
shared vec3  s_verts_in[max_verts_support]; // Shared load of b_vert_in buffer
shared uvec4 s_elems_in[max_elems_support]; // Shared load of b_elem_in buffer

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_verts; i += gl_WorkGroupSize.x)
    s_verts_in[i] = b_vert_in.data[i];
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_elems; i += gl_WorkGroupSize.x)
    s_elems_in[i] = b_elem_in.data[i];
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();
  
  const uint i = gl_GlobalInvocationID.x;
  guard(i < b_unif.n);
  
  vec3 p = b_posi_in.data[i];
  
  float result_err  = FLT_MAX;
  vec4 result_bary;
  uint result_indx;

  for (uint j = 0; j < b_unif.n_elems; ++j) {
    uvec4 elem = s_elems_in[j];

    // Compute barycentric weights for this tetrahedron
    vec3 sub = s_verts_in[elem.w];
    mat3 t = inverse(mat3(s_verts_in[elem.x] - sub, s_verts_in[elem.y] - sub, s_verts_in[elem.z] - sub));
    vec3 xyz = t * (p - sub);
    vec4 bary = vec4(xyz, 1.f - hsum(xyz));

    // Compute squared error of potentially negative barycentric weights
    float err = dot(bary, clamp(bary, 0, 1));

    // Store best result if error is improved
    guard_continue(err < result_err);
    result_err  = err;
    result_bary = bary;
    result_indx = j;

    // Exit early if error is zero
    guard_break(err != 0);
  }

  // Store result, packing 3/4th of weights, together with the tetrahedron's index
  b_bary_out.data[i] = vec4(result_bary.xyz, uintBitsToFloat(result_indx));
}