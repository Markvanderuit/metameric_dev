#version 460 core

#include <guard.glsl>
#include <math.glsl>

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_0 { vec3  data[]; } b_vert_in;
layout(binding = 1) restrict readonly  buffer b_1 { uvec4 data[]; } b_elem_in;
layout(binding = 2) restrict readonly  buffer b_2 { vec3  data[]; } b_posi_in;
layout(binding = 3) restrict writeonly buffer b_3 { vec4  data[]; } b_bary_out;

// Uniform buffer declarations
layout(binding = 0) uniform u_0 {
  uint n;
  uint n_verts;
  uint n_elems;
} b_unif;

// Constants
const uint max_verts = 256;
const uint max_elems = 256;

shared vec3  s_verts_in[max_verts];
shared uvec4 s_elems_in[max_elems];

void load_shared_data() {
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_verts; i += gl_WorkGroupSize.x)
    s_verts_in[i] = b_vert_in.data[i];
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_elems; i += gl_WorkGroupSize.x)
    s_elems_in[i] = b_elem_in.data[i];

  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared_data();
  
  const uint i = gl_GlobalInvocationID.x;
  guard(i < b_unif.n);
  
  vec3 p = b_posi_in.data[i];
  
  float err_ = 1000.f;
  vec4 bary_ = vec4(0);
  uint j_ = 0;

  for (uint j = 0; j < b_unif.n_elems; ++j) {
    uvec4 elem = s_elems_in[j];
    mat3 t = inverse(mat3(s_verts_in[elem[0]] - s_verts_in[elem[3]],
                          s_verts_in[elem[1]] - s_verts_in[elem[3]],
                          s_verts_in[elem[2]] - s_verts_in[elem[3]]));
    vec3 xyz = t * (p - s_verts_in[elem[3]]);
    vec4 bary = vec4(xyz, 1.f - hsum(xyz));

    // Take closest fit
    float err = dot(bary, clamp(bary, 0, 1));
    if (err < err_) {
      bary_ = bary;
      j_ = j;
      err_ = err;
      break;
    }
  }

  // Store result, packing 3/4th of weights together with the element index
  b_bary_out.data[i] = vec4(bary_.xyz, uintBitsToFloat(j_));
}