#version 460 core

#include <guard.glsl>
#include <math.glsl>
#include <spectrum.glsl>

const uint n_elems_max = 24;
const uvec3 _ip = uvec3(1, 2, 0);
const uvec3 _im = uvec3(2, 0, 1);

#define Wght float[barycentric_weights]

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_0 { vec3  data[]; } b_vert_in;
layout(binding = 1) restrict readonly  buffer b_1 { uvec3 data[]; } b_elem_in;
layout(binding = 2) restrict readonly  buffer b_2 { vec3  data[]; } b_posi_in;
layout(binding = 3) restrict writeonly buffer b_3 { Wght  data[]; } b_bary_out;

// Uniform buffer declarations
layout(binding = 0) uniform u_0 {
  uint n;
  uint n_verts;
  uint n_elems;
} b_size;

// Shared memory declarations
shared vec3  s_verts_in[barycentric_weights];
shared uvec3 s_elems_in[n_elems_max];

void load_shared_data() {
  const uint i = gl_LocalInvocationID.x;
  if (i < b_size.n_verts)
    s_verts_in[i] = b_vert_in.data[i];
  if (i < b_size.n_elems)
    s_elems_in[i] = b_elem_in.data[i];
  barrier();
  memoryBarrierShared();
}

// Define to perform commonly occuring iteration
#define weights_iter(__b)      for (uint __b = 0; __b < b_size.n_verts; ++__b)
#define weights_iter_full(__b) for (uint __b = 0; __b < barycentric_weights; ++__b)

Wght constr_weights(in float f) {
  Wght w;
  weights_iter_full(i) w[i] = f;
  return w;
}

float sum_weights(in Wght w) {
  float f;
  weights_iter(i) f += w[i];
  return f;
}

void scatter_add_weights(inout Wght w, in vec3 w_, in uvec3 i) {
  w[i[0]] += w_[0];
  w[i[1]] += w_[1];
  w[i[2]] += w_[2];
}

vec3 shift(in vec3 v, in uvec3 i) { return vec3(v[i[0]], v[i[1]], v[i[2]]); }
uvec3 shift(in uvec3 v, in uvec3 i) {  return uvec3(v[i[0]], v[i[1]], v[i[2]]); }

// Enum flags for per-triangle MVC computation return type
#define MVCReturnOnVertex   0x01u
#define MVCReturnOnTriangle 0x02u
#define MVCReturnOnPlane    0x04u
#define MVCReturnCorrect    0x08u

// Return result for per-triangle MVC computation
struct MVCReturnObject {
  vec3 weight;
  uint type;
};

MVCReturnObject mean_value_coords_per_tri(in vec3 x, in uvec3 v) {
  MVCReturnObject result;

  // Compute per-vertex data
  vec3 d, u[3];
  for (uint i = 0; i < 3; ++i) {
    vec3 p = s_verts_in[v[i]];

    d[i] = length(p - x);

    // Fallback: x lies near or on vertex, return value directly
    if (d[i] <= M_EPS) {
      result.weight[i] = 1;
      result.type = MVCReturnOnVertex;
      return result;
    }

    u[i] = normalize(p - x);
  }

  // Compute spherical triangle data
  vec3 theta = 2.f * asin(.5f * vec3(length(u[1] - u[2]), 
                                     length(u[2] - u[0]), 
                                     length(u[0] - u[1])));
    
  // Fallback: x lies near or on triangle, use 2D barycentric coordinates
  float h = .5f * hsum(theta);
  if (M_PI - h <= M_EPS) {
    result.weight = sin(theta) * shift(d, _ip) * shift(d, _im);
    result.type = MVCReturnOnTriangle;
    return result;
  }

  vec3 sin_theta = sin(theta);
  vec3 c = (2.f * sin(h) * sin(h - theta)) 
         / (shift(sin_theta, _ip) * shift(sin_theta, _im)) 
         - 1.f;
  vec3 s = sign(determinant(transpose(mat3(u[0], u[1], u[2])))) 
         * sqrt(1.f - c * c);

  // Fallback: x lies on triangle's plane but way outside triangle, ignore weights
  if (any(lessThan(abs(s), vec3(M_EPS)))) {
    result.type = MVCReturnOnPlane;
    return result;
  }

  // Compute actual weights as we are somewhere inside
  result.weight = (theta - 
                   shift(c, _ip) * shift(theta, _im) - 
                   shift(c, _im) * shift(theta, _ip))
                / (d * shift(sin_theta, _ip) * shift(s, _im));
  result.type = MVCReturnCorrect;
  return result;
}

Wght mean_value_coords_total(in vec3 x) {
  Wght weight = constr_weights(0.f);

  for (uint j = 0; j < b_size.n_elems; ++j) {
    const uvec3 v = s_elems_in[j];
    MVCReturnObject result = mean_value_coords_per_tri(x, v);
    
    // Catch special case which returns no value
    if (result.type == MVCReturnOnPlane)
      continue;

    // Catch NANs and set respective weight to zero
    if (any(isnan(result.weight)))
      continue;

    // Catch special cases which return their own value directly
    if (result.type == MVCReturnOnVertex || result.type == MVCReturnOnTriangle) {
      weight = constr_weights(0.f);
      scatter_add_weights(weight, result.weight, v);
      break;
    }

    scatter_add_weights(weight, result.weight, v);
  }

  float wsum = sum_weights(weight);
  if (wsum != 0.f)
    weights_iter(i) weight[i] /= wsum;
  return weight;
}

void main() {
  load_shared_data();
  
  const uint i = gl_GlobalInvocationID.x;
  guard(i < b_size.n);
  b_bary_out.data[i] = mean_value_coords_total(b_posi_in.data[i]);;
}