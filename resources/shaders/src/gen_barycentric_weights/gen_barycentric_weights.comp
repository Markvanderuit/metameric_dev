#version 460 core

// Enable necessary subgroup extensions
#extension GL_KHR_shader_subgroup_basic      : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_clustered  : require

#pragma optionNV(fastmath on)
#pragma optionNV(fastprecision on)

#include <guard.glsl>
#include <math.glsl>
#include <bary.glsl>

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_0 { vec3  data[]; } b_vert_in;
layout(binding = 1) restrict readonly  buffer b_1 { uvec3 data[]; } b_elem_in;
layout(binding = 2) restrict readonly  buffer b_2 { vec3  data[]; } b_posi_in;
layout(binding = 3) restrict writeonly buffer b_3 { Bary4 data[]; } b_bary_out;

// Uniform buffer declarations
layout(binding = 0) uniform u_0 {
  uint n;
  uint n_verts;
  uint n_elems;
} b_unif;

// Shared memory declarations
shared vec3  s_verts_in[mvc_weights];
shared uvec3 s_elems_in[2 * mvc_weights];
shared Bary4 s_bary_out[gl_WorkGroupSize.x];

void load_shared_data() {
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_verts; i += gl_WorkGroupSize.x)
    s_verts_in[i] = b_vert_in.data[i];
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_elems; i += gl_WorkGroupSize.x)
    s_elems_in[i] = b_elem_in.data[i];
  barrier();
  memoryBarrierShared();
}

float norm_weights(in Bary4 w) {
  float n = 0.f;
  for (uint j = 0; j < mvc_weights / 4; ++j)
    n += hsum(w[j]);
  return n;
}

void normalize_weights(inout Bary4 w) {
  float n = 1.f / norm_weights(w);
  for (uint j = 0; j < mvc_weights / 4; ++j)
    w[j] *= n;
}

void clear_weights(inout Bary4 w, float value) {
  for (uint i = 0; i < mvc_weights / 4; ++i)
    w[i] = vec4(value);
}

void scatter_weights(inout Bary4 w, in vec3 w_, in uvec3 i) {
  const uvec3 i_ = i / 4;
  const uvec3 j_ = i % 4;
  w[i_[0]][j_[0]] += w_[0];
  w[i_[1]][j_[1]] += w_[1];
  w[i_[2]][j_[2]] += w_[2];
}

// Enum flags for per-triangle MVC computation return type
#define MVCReturnOnVertex   0x01u
#define MVCReturnOnTriangle 0x02u
#define MVCReturnOnPlane    0x04u
#define MVCReturnCorrect    0x08u

// Return result for per-triangle MVC computation
struct MVCObject {
  vec3 weight;
  uint type;
};

MVCObject mean_value_coords_per_tri(in vec3 p, in uvec3 el) {
  // Compute per-vertex direction vectors and vector lengths for this particular element
  mat3 u = mat3((s_verts_in[el[0]] - p), (s_verts_in[el[1]] - p), (s_verts_in[el[2]] - p));
  vec3 d = vec3(length(u[0]), length(u[1]), length(u[2]));

  // Fallbacks: test if x lies near or on a vertex, weight that vertex as 1 and return directly
  bvec3 on_vert_mask = lessThan(d, vec3(M_EPS));
  if (any(on_vert_mask))
    return MVCObject(mix(vec3(0), vec3(1), on_vert_mask), MVCReturnOnVertex);
  
  // Normalize vector directions  in 'u'
  for (uint i = 0; i < 3; ++i)
    u[i] /= d[i];
  
  // Compute spherical triangle data
  vec3 theta = 2.f * asin(.5f * vec3(length(u[1] - u[2]), length(u[2] - u[0]), length(u[0] - u[1])));
  vec3 sin_theta = sin(theta);
  float h = .5f * hsum(theta);
    
  // Fallback: test if x lies near or on triangle, return 2D barycentric coordinates
  if (abs(M_PI - h) <= M_EPS)
    return MVCObject(sin_theta * d.yzx * d.zxy, MVCReturnOnTriangle);

  vec3 c = (2.f * sin(h) * sin(h - theta)) / (sin_theta.yzx * sin_theta.zxy) - 1.f;
  vec3 s = sign(determinant(u)) * sqrt(max(1.f - c * c, M_EPS));

  // Fallback: test if x lies on triangle's plane but way outside triangle, set weights to 0
  if (any(lessThanEqual(abs(s), vec3(M_EPS))))
    return MVCObject(vec3(0), MVCReturnOnPlane);

  // Finally; compute actual weight and return
  vec3 w = (theta - c.yzx * theta.zxy - c.zxy * theta.yzx) / (d * sin_theta.yzx * s.zxy);
  return MVCObject(w, MVCReturnCorrect);
}

void mean_value_coords_total(inout Bary4 weight, in vec3 p) {
  clear_weights(weight, 0.f);

  for (uint j = 0; j < b_unif.n_elems; ++j) {
    const uvec3 el = s_elems_in[j];
    MVCObject result = mean_value_coords_per_tri(p, el);

    // Skip invalid results
    if (any(isnan(result.weight)))
      continue;

    // Test for special cases which return their own value directly, clear the weight again
    bool clear_return = result.type == MVCReturnOnVertex || result.type == MVCReturnOnTriangle;
    if (clear_return && j > 0)
      clear_weights(weight, 0.f);

    scatter_weights(weight, result.weight, el);

    // Given special cases which return their own value directly, exit early
    if (clear_return)
      break;
  }

  normalize_weights(weight);
}

void main() {
  load_shared_data();
  
  const uint i = gl_GlobalInvocationID.x;
  guard(i < b_unif.n);
  
  mean_value_coords_total(s_bary_out[gl_LocalInvocationID.x], b_posi_in.data[i]);
  b_bary_out.data[i] = s_bary_out[gl_LocalInvocationID.x];
}