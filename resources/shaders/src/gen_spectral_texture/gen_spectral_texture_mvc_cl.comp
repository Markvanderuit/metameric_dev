#version 460 core

// Enable necessary subgroup extensions
#extension GL_KHR_shader_subgroup_basic      : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_clustered  : require

#include <guard.glsl>
#include <spectrum_invoc.glsl>
#include <spectrum_cluster.glsl>

#define Spec ClSpec             // Use shorthand for clustered types
const uint max_gamut_verts = 8; // Nr. of tetrahedron vertices supported

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_0 { InSpec data[]; } b_spec_gamut;
layout(binding = 1) restrict readonly  buffer b_1 { vec3   data[]; } b_colr_gamut;
layout(binding = 2) restrict readonly  buffer b_2 { uvec3  data[]; } b_elem_gamut;
layout(binding = 3) restrict readonly  buffer b_3 { vec3   data[]; } b_colr_texture;
layout(binding = 4) restrict writeonly buffer b_4 { InSpec data[]; } b_spec_texture;

// Uniform buffer declarations
layout(binding = 0) uniform u_0 {
  uint n;
  uint n_verts;
  uint n_elems;
} b_size;

// Shared memory declarations
shared InSpec s_spectral_gamut[max_gamut_verts];

void load_gamut_shared_in() {
  const uint i = gl_LocalInvocationID.x / wavelength_samples_al;
  const uint j = gl_LocalInvocationID.x % wavelength_samples_al;
  
  if (i < b_size.n_verts && j < wavelength_samples)
    s_spectral_gamut[i][j] = b_spec_gamut.data[i][j];

  barrier();
  memoryBarrierShared();
}

Spec load_gamut_shared_cl(uint i) {
  Spec s;
  cl_spec_scatter(s, s_spectral_gamut[i]);
  return s;
}

void store_spec_texture(in Spec s, uint i) {
  cl_spec_gather(b_spec_texture.data[i], s);
}

struct MVCResult {
  Spec s;
  float w;
  bool ret;
};

// The following block is a near-direct implementation of MVC pseudocode 
// from "Mean Value Coordinates for Closed Triangular Meshes", Ju et al, 
// Rice University, 2005.
Spec query_spectrum_mvc_baseline(in vec3 x) {
  // Hardcoded constants describing triangle mesh layout
  const uint n_elems = b_size.n_elems;
  const uint n_verts = 3;

  // Results
  Spec  total_s = Spec(0);
  float total_w = 0.f;

  // Per triangle:
  for (uint j = 0; j < n_elems; ++j) {
    const uvec3 verts = b_elem_gamut.data[j];

    // Results
    Spec  local_s = Spec(0);
    float local_w = 0.f;

    // Compute |p - x| and normalized (p - x) / |p - x|
    float d[n_verts];
    vec3  u[n_verts];
    for (uint i = 0; i < n_verts; ++i) {
      vec3 p = b_colr_gamut.data[verts[i]];
      d[i] = length(p - x);
      u[i] = (p - x) / d[i];

      // Fallback: x lies close-to or on vertex, return value directly
      if (d[i] < M_EPS)
        return load_gamut_shared_cl(verts[i]);
    }

    // Spherical triangle data
    float theta[n_verts];
    float h = 0.f;
    for (uint i = 0; i < n_verts; ++i) {
      uint ip = (i + 1) % n_verts, im = (i + 2) % n_verts;

      theta[i] = 2.f * asin(length(u[ip] - u[im]) / 2.f);
      h += theta[i];
    }
    h /= 2.f;

    // Fallback: x lies on triangle, use 2D barycentric coordinates
    if (M_PI - h < M_EPS) {
      float w[n_verts];
      for (uint i = 0; i < n_verts; ++i) {
        uint ip = (i + 1) % n_verts, im = (i + 2) % n_verts;
        w[i] = sin(theta[i]) * d[im] * d[ip];
      }
      for (uint i = 0; i < n_verts; ++i) {
        local_s += w[i] * load_gamut_shared_cl(verts[i]);
        local_w += w[i];
      }
      return local_s / local_w;
    }

    float c[n_verts];
    float s[n_verts];
    float det = determinant((mat3(u[0], u[1], u[2])));
    for (uint i = 0; i < n_verts; ++i) {
      uint ip = (i + 1) % n_verts, im = (i + 2) % n_verts;

      c[i] = (2.f * sin(h) * sin(h - theta[i])) 
          / (sin(theta[ip]) * sin(theta[im]))
          - 1.f;
      s[i] = sign(det) * sqrt(1.f - (c[i] * c[i]));
    }

    // Fallback: x lies outside triangle but on same plane, return nothing
    bool x_continue = false;
    for (uint i = 0; i < n_verts; ++i) {
      if (abs(s[i]) < M_EPS)
        x_continue = true;
    }

    if (x_continue)
      continue;

    float w[n_verts];
    for (uint i = 0; i < n_verts; ++i) {
      uint ip = (i + 1) % n_verts, im = (i + 2) % n_verts;

      w[i] = (theta[i] - c[ip] * theta[im] - c[im] * theta[ip])
           / (d[i] * sin(theta[ip]) * s[im]);
    }
    
    // Sum together spectra and weights
    for (uint i = 0; i < n_verts; ++i) {
      local_s += w[i] * load_gamut_shared_cl(verts[i]);
      local_w += w[i];
    }

    total_s += local_s;
    total_w += local_w;
  }

  return total_s / total_w;
}

void main() {
  const uint i = gl_GlobalInvocationID.x / cl_spectrum_invc_n;
  guard(i < b_size.n);

  // Load spectral gamut data into shared memory
  load_gamut_shared_in();

  // Query a spectrum result using one of the provided methods
  Spec sd = query_spectrum_mvc_baseline(b_colr_texture.data[i]);

  // Store results to buffer
  store_spec_texture(sd, i);
  // store_spec_texture(clamp(sd, 0.f, 1.f), i); // Note: should only enforce clamp on export?
}