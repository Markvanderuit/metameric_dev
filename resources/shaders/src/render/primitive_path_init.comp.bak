#include <preamble.glsl>
#include <guard.glsl>
#include <gbuffer.glsl>
#include <math.glsl>
#include <ray.glsl>
#include <scene.glsl>

// General layout rule declarations
layout(local_size_x = 16, 
       local_size_y = 16) in;
layout(std140)            uniform;
layout(std430)            buffer;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_unif {
  mat4  view_inv;  // inverse(view);
  uvec2 view_size; // width, height of image
  float fovy_tan;  // tan(fov_y * .5f);
  float aspect;    // vec2(aspect, 1);
} buff_unif;

// Storage buffer declarations
layout(binding = 0) restrict coherent  buffer b_buff_path_head   { uint n;          } buff_path_head;        // Size of work queue
layout(binding = 1) restrict writeonly buffer b_buff_path_data   { PathInfo data[]; } buff_path_data;        // Work path data

// Sampler/texture declarations
layout(binding = 0) uniform usampler2D b_gbuffer; // G-buffer texture pack

// Ray get_gbuffer_ray(in uvec2 xy) {
//   // Unpack current pixel from packed PathInfo
//   const vec2 uv = (vec2(xy) + .5f) / vec2(buff_unif.view_size);

//   const GBufferRay gb = unpack_gbuffer_ray(texture(b_gbuffer, uv));

//   // Get NDC pixel coordinate
//   vec2 s = (uv - .5f) * 2.f * buff_unif.fovy_tan * vec2(buff_unif.aspect, 1);
  
//   // Generate camera ray; 
//   // use GBuffer to fill ray distance as if an intersect already took place
//   Ray r;
//   r.o = (buff_unif.view_inv * vec4(0, 0, 0, 1)).xyz;
//   r.d = gb.p - r.o;
//   r.t = length(r.d);
//   r.d /= r.t;

//   // If the GBuffer did not identify an object id, we actually missed
//   if (gb.object_i == OBJECT_INVALID) {
//     r.t = FLT_MAX;
//   }

//   return r;
// }

void main() {
  // // 2D/1D image/buffer coordinates
  // const uvec2 xy = gl_GlobalInvocationID.xy;
  // const uint  i  = xy.y * buff_unif.view_size.x + xy.x;
  // guard(all(lessThan(xy, buff_unif.view_size)));

  // // Set up a new PathInfo object, fill in per-pixel data
  // PathInfo pi;
  // pi.pixel = (xy.x & 0x0000FFFF) | (xy.y << 16); // Pixels are not going to exceed 2^16, so pack em
  // pi.state = i; // Pixel index forms initial rng state
  // pi.depth = 0; // New path is recognizable by depth of 0

  // // Test the GBuffer's initial camera ray for a hit
  // // Ona miss, we do not even submit the path for work
  // if (get_gbuffer_ray(xy).t != FLT_MAX) {
  //   // Get next index in work queue, then submit the path
  //   uint path_i = atomicAdd(buff_path_head.n, 1);
  //   buff_path_data.data[path_i] = pi;
  // }
}