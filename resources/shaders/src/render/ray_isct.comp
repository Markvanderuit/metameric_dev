#include <preamble.glsl>
#include <guard.glsl>
#include <math.glsl>
#include <bvh.glsl>
#include <scene.glsl>

// General layout rule declarations
layout(local_size_x_id = 0) in;
layout(std140)              uniform;
layout(std430)              buffer;

// Uniform declarations
layout(binding = 0) uniform b_buff_unif {
  mat4  view_inv;  // inverse(view);
  uvec2 view_size; // width, height of image
  float fovy_tan;  // tan(fov_y * .5f);
  float aspect;    // vec2(aspect, 1); 
} buff_unif;

// Storage declarations
layout(binding = 0) restrict readonly buffer b_buff_bvhs_info {
  BVHInfo data[];
} buff_bvhs_info;
layout(binding = 1) restrict readonly buffer b_buff_bvhs_node {
  BVHNodePack data[];
} buff_bvhs_node;
layout(binding = 2) restrict readonly buffer b_buff_bvhs_prim {
  BVHPrimPack data[];
} buff_bvhs_prim;
layout(binding = 3) restrict readonly buffer b_buff_objc_info {
  ObjectInfo data[];
} buff_objc_info;
layout(binding = 4) restrict coherent buffer b_buff_work_head {
  uint value;
} buff_work_head;
layout(binding = 5) restrict coherent buffer b_buff_work {
  Ray data[];
} buff_work;

// Image unit, output declaration
// TODO remove
layout(binding = 0, rgba32f) uniform restrict image2D b_target_4f;

// Shared memory declarations
shared ObjectInfo s_objc_info[8];
shared BVHInfo    s_bvhs_info[8];
shared uint       s_stack[gl_WorkGroupSize.x][16];

// Define names of scene buffers to replace preproc in intersect.glsl
// to work around glsl's lack of ssbo argument passing
#define isct_n_objects      buff_objc_info.data.length()
#define isct_stack          s_stack[gl_LocalInvocationID.x]
#define isct_buff_objc_info s_objc_info
#define isct_buff_bvhs_info s_bvhs_info
#define isct_buff_bvhs_node buff_bvhs_node.data
#define isct_buff_bvhs_prim buff_bvhs_prim.data
#include <intersect.glsl>

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; 
            i < buff_objc_info.data.length();
            i += gl_WorkGroupSize.x) {
    s_objc_info[i] = buff_objc_info.data[i];
  }
  memoryBarrierShared();
  barrier();

  for (uint i = gl_LocalInvocationID.x; 
            i < buff_bvhs_info.data.length();
            i += gl_WorkGroupSize.x) {
    s_bvhs_info[i] = buff_bvhs_info.data[i];
  }
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();

  const uint i = gl_GlobalInvocationID.x;
  guard(i < buff_work_head.value);

  // Grab ray, do ray-scene intersection, get surface info
  SurfaceInfo si = ray_intersect(buff_work.data[i]);

  // For now, set a pixel to a specific color based on the query
  if (si.object_i != OBJECT_INVALID) {
    uvec2 xy = uvec2(i % buff_unif.view_size.x, i / buff_unif.view_size.x);
    imageStore(b_target_4f, ivec2(xy), vec4(si.n, 1));
  }
}