#include <preamble.glsl>
#include <guard.glsl>
#include <math.glsl>
#include <random_uniform.glsl>
#include <ray.glsl>
#include <bvh.glsl>
#include <scene.glsl>

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std140)             uniform;
layout(std430)             buffer;

// // Uniform buffer declarations
// layout(binding = 0) uniform b_buff_unif {
//   mat4  view_inv;  // inverse(view);
//   uvec2 view_size; // width, height of image
//   float fovy_tan;  // tan(fov_y * .5f);
//   float aspect;    // vec2(aspect, 1);

//   // TODO; newly added, not yet defined on other side
//   uint max_depth;
// } buff_unif;

// // Storage buffer declarations
// layout(binding = 0) restrict readonly  buffer b_buff_path_head   { uint        n;      } buff_path_head;   // Size of work queue
// layout(binding = 1) restrict           buffer b_buff_path_data   { PathInfo    data[]; } buff_path_data;   // Work path data
// layout(binding = 2) restrict readonly  buffer b_buff_extend_inpt { Ray         data[]; } buff_extend_inpt; // Work ray data
// layout(binding = 3) restrict coherent  buffer b_buff_extend_head { uint        n;      } buff_extend_head; // Size of work queue
// layout(binding = 4) restrict writeonly buffer b_buff_extend_oupt { Ray         data[]; } buff_extend_oupt; // Work ray data
// layout(binding = 5) restrict readonly  buffer b_buff_shadow_inpt { Ray         data[]; } buff_shadow_inpt; // Work ray data
// layout(binding = 6) restrict coherent  buffer b_buff_shadow_head { uint        n;      } buff_shadow_head; // Size of work queue
// layout(binding = 7) restrict writeonly buffer b_buff_shadow_oupt { Ray         data[]; } buff_shadow_oupt; // Work ray data
// layout(binding = 8) restrict readonly  buffer b_buff_bvhs_prim   { BVHPrimPack data[]; } buff_bvhs_prim;   // Packed surface primitives

// // Sampler/texture declarations
// layout(binding = 1) uniform usampler2D     b_gbuffer; // G-buffer texture used for initial ray hits
// layout(binding = 2) uniform sampler1DArray b_csys_3f; // Color system spectra, 3 components // TODO Should extract

// // Image unit, output declaration
// layout(binding = 0, rgba32f) uniform restrict image2D b_target_4f;

// // Set name of surface primitive buffer, and include surface.glsl
// #define srfc_buff_prim buff_bvhs_prim.data
// #include <surface.glsl>

// // Hardcoded value for now
// vec3 hardcoded_lpos = vec3(10, 10, 10); // 10 * vec3(-1, 1, 1);

// Ray get_gbuffer_ray(in PathInfo pi) {
//   // Unpack current pixel from packed PathInfo
//   const ivec2 xy = get_path_pixel(pi);
//   const  vec2 uv = (vec2(xy) + .5f) / vec2(buff_unif.view_size);

//   const GBufferRay gb = unpack_gbuffer_ray(texture(b_gbuffer, uv));

//   // Get NDC pixel coordinate
//   vec2 s = (uv - .5f) * 2.f * buff_unif.fovy_tan * vec2(buff_unif.aspect, 1);
  
//   // Generate camera ray; 
//   // use GBuffer to fill ray distance as if an intersect already took place
//   Ray r;
//   r.o = (buff_unif.view_inv * vec4(0, 0, 0, 1)).xyz;
//   r.d = gb.p - r.o;
//   r.t = length(r.d);
//   r.d /= r.t;

//   // If the GBuffer did not identify an object id, we actually missed
//   if (gb.object_i == OBJECT_INVALID) {
//     r.t = FLT_MAX;
//   }

//   return r;
// }

// Ray get_extend_ray(in PathInfo pi) {
//   if (pi.depth > 0) {
//     return get_gbuffer_ray(pi);
//   } else {
//     // If path has restarted, we extract first hit from GBuffer data
//     return buff_extend_inpt.data[pi.ray_extend_i];
//   }
// }

// Ray get_shadow_ray(in PathInfo pi) {
//   if (pi.depth > 0 && pi.ray_shadow_i != UINT_MAX) {
//     return buff_shadow_inpt.data[pi.ray_shadow_i];
//   } else {
//     // If path has restarted, first shadow ray does not exist
//     return Ray(vec3(0), FLT_MAX, vec3(0), 0xFFFFFFFFu);
//   }
// }

// uint push_extend_ray(in Ray ray) {
//   // Get next index in work queue, then submit the ray
//   uint next_i = atomicAdd(buff_extend_head.n, 1);
//   buff_extend_oupt.data[next_i] = ray;
//   return next_i;
// }

// uint push_shadow_ray(in Ray ray) {
//   // Get next index in work queue, then submit the ray
//   uint next_i = atomicAdd(buff_shadow_head.n, 1);
//   buff_shadow_oupt.data[next_i] = ray;
//   return next_i;
// }

// // Offset epsilon copied from mitsuba3
// vec3 gen_offset_p(in SurfaceInfo si, in vec3 d) {
//   float mag = 1.f + hmax(abs(si.p)) + 1500.f * M_EPS;
//   mag = dot(si.n, d) >= 0 ? mag : -mag;
//   return fma(vec3(mag), si.n, si.p);
// }

// vec3 sample_colsys(in uint colsys_i, in float wvl) {
//   return texture(b_csys_3f, vec2(wvl, colsys_i)).xyz;
// }

// void write_path_radiance(in PathInfo pi) {
//   ivec2 px = get_path_pixel(pi);
//   vec3 colr = imageLoad(b_target_4f, px).xyz;
//   colr += sample_colsys(0, pi.wavelength) * pi.radiance;
//   imageStore(b_target_4f, px, vec4(colr, 1));
// }

void main() {
  // // Thread index is work index
  // const uint i = gl_GlobalInvocationID.x;
  // guard(i < buff_path_head.n);
  
  // // Load path info from work buffer. New paths are set to default
  // PathInfo pi = buff_path_data.data[i];
  // if (pi.depth == 0)
  //   reset(pi);

  // // Emitter sampling; handle last bounce's shadow ray to incorporate
  // // direct illumination
  // if (pi.depth > 0 && !bool(get_shadow_ray(pi).data)) {
  //   // TODO MIS
  //   pi.radiance += pi.throughput * (pi.ray_shadow_e / (pi.p * pi.ray_shadow_pdf));
  // }

  // // Get surface info at next hit
  // Ray extend_ray = get_extend_ray(pi);
  // SurfaceInfo si = get_surface_info(extend_ray);
  
  // // Note that the first (gbuffer) ray is guaranteed to hit, as the path is
  // // otherwise never scheduled
  // if (si.object_i == OBJECT_INVALID) {
  //   write_path_radiance(pi);
  //   pi.depth               = 0;
  //   buff_path_data.data[i] = pi;
  //   return;
  // }

  // // Incorporate BSDF throughput from the last iteration
  // pi.throughput *= pi.ray_extend_t;
  // pi.p          *= pi.ray_extend_pdf;

  // // Incorporate emission from a surface hit directly by the path
  // // TODO test if object is emissive, or a light source
  // //      to end path and return early
  // /* if (Le) {
  //   if (pi.depth == 0 || !pi.did_scatter) {
  //     // ...
  //   } else {
  //     // ...
  //   }
  // } */

  // // Increment path length and terminate if maximum is reached, returingn early
  // if (pi.depth++ >= buff_unif.max_depth) {
  //   write_path_radiance(pi);
  //   pi.depth               = 0;
  //   buff_path_data.data[i] = pi;
  //   return;
  // }

  // // Russian roulette; potentially terminate path
  // float rr_throughput = pi.throughput * pi.eta;
  // if (rr_throughput < 1.f && pi.depth > 1) {
  //   float q = max(0.f, 1.f - rr_throughput);
  //   if (next_1d(pi.state) < q) {
  //     write_path_radiance(pi);
  //     pi.depth               = 0;
  //     buff_path_data.data[i] = pi;
  //     return;
  //   }
  //   pi.throughput /= (1.f - q);
  // }

  // // Get BSDF
  // // Weird quirk; gather BSDF's underlying data once
  // // TODO; instead construct surface BSDF object here
  // //       it's going to be used anyways
  // float r = .5f; // TOOD evaluate instead of hardcoding you pancake

  // // Emitter sampling; generate sample/ray for next iteration
  // {
  //   // Sample position in cube
  //   vec3 lpos = hardcoded_lpos + next_3d(pi.state) * 4.f - 2.f;

  //   // Generate shadow ray
  //   Ray ray;
  //   ray.d = lpos - si.p;
  //   ray.t = length(ray.d);
  //   ray.d /= ray.t;
  //   ray.o = si.p + gen_offset_p(si, ray.d);
  //   ray.data = 0xFFFFFFFFu;

  //   // Store throughput, probability for next iteration, and push shadow test
  //   // TODO eval() on the bsdf
  //   pi.ray_shadow_i   = push_shadow_ray(ray);    
  //   pi.ray_shadow_e   = r * dot(si.ns, ray.d);
  //   pi.ray_shadow_pdf = 1.f; // Wrong, but correct for now
  // }
  
  // // BSDF sampling; generate sample/ray for next iteration
  // {
  //   // Generate extend ray
  //   Ray ray;
  //   ray.d    = reflect(extend_ray.d, si.ns);
  //   ray.o    = si.p + gen_offset_p(si, ray.d);
  //   ray.t    = FLT_MAX;
  //   ray.data = 0xFFFFFFFFu;

  //   pi.ray_extend_i   = push_extend_ray(ray);
  //   pi.ray_extend_t   = r * dot(si.ns, ray.d);
  //   pi.ray_extend_pdf = 1.f;
  // }
}