#include <preamble.glsl>
#include <guard.glsl>
#include <gbuffer.glsl>
#include <math.glsl>
#include <ray.glsl>
#include <scene.glsl>

// General layout rule declarations
layout(local_size_x = 16, 
       local_size_y = 16) in;
layout(std140)            uniform;
layout(std430)            buffer;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_unif {
  mat4  view_inv;  // inverse(view);
  uvec2 view_size; // width, height of image
  float fovy_tan;  // tan(fov_y * .5f);
  float aspect;    // vec2(aspect, 1);
} buff_unif;

// Storage buffer declarations
layout(binding = 0) restrict coherent  buffer b_buff_path_head   { uint n;          } buff_path_head;        // Size of work queue
layout(binding = 1) restrict writeonly buffer b_buff_path_data   { PathInfo data[]; } buff_path_data;        // Work path data
layout(binding = 2) restrict coherent  buffer b_buff_extend_head { uint n;          } buff_extend_work_head; // Size of work queue
layout(binding = 3) restrict writeonly buffer b_buff_extend_data { Ray  data[];     } buff_extend_work_data; // Work ray data

// Sampler/texture declarations
layout(binding = 0) uniform usampler2D b_gbuffer; // G-buffer texture pack

Ray generate_ray(in vec2 xy, in GBufferRay gb) {
  // Get NDC pixel coordinate
  vec2 s = (xy - .5f) * 2.f * buff_unif.fovy_tan * vec2(buff_unif.aspect, 1);
  
  // Generate camera ray; 
  // use GBuffer to fill ray distance as if an intersect already took place
  Ray r;
  r.o = (buff_unif.view_inv * vec4(0, 0, 0, 1)).xyz;
  r.d = gb.p - r.o;
  r.t = length(r.d);
  r.d /= r.t;

  // If the GBuffer did not identify an object id, we actually missed
  if (get_gbuffer_data_objc(gb) == OBJECT_INVALID) {
    r.t = FLT_MAX;
  }

  return r;
}

void main() {
  // 2D/1D image/buffer coordinates
  const uvec2 xy = gl_GlobalInvocationID.xy;
  const vec2  uv = (vec2(xy) + 0.5) / vec2(buff_unif.view_size);
  const uint  i  = xy.y * buff_unif.view_size.x + xy.x;

  // Discard overflow invocations
  guard(all(lessThan(xy, buff_unif.view_size)));

  // Read and unpack GBuffer data at current pixel
  GBufferRay gb = unpack_gbuffer_ray(texture(b_gbuffer, uv));

  // Set up a new PathInfo object fill in per-pixel data
  PathInfo pi;
  pi.pixel = (xy.x & 0x0000FFFF) | (xy.y << 16); // Pixels are not going to exceed 2^16, so pack em
  pi.state = i; // Pixel index forms initial rng state
  pi.depth = 0; // New path recognizable by depth of 0

  // Generate camera ray; use GBuffer to fill data as if an intersect took place
  Ray ray = generate_ray(uv, gb);

  // On a ray miss, we do not submit ray or path for any further computation
  if (ray.t != FLT_MAX) {
    // Get index for a new path/ray on work queue
    uint path_i = atomicAdd(buff_path_head.n, 1);
    
    // Fill in ray flags on PathInfo s.t. a previous extension ray exists
    pi.ray_extend_i = path_i;
    pi.ray_shadow_i = 0;
    
    // Store results
    buff_path_data.data[path_i] = pi;
    buff_extend_work_data.data[path_i] = ray;
  }
}