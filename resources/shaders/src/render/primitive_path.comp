#include <preamble.glsl>
#include <distribution.glsl>
#include <spectrum.glsl>
#include <math.glsl>
#include <sampler/uniform.glsl>
#include <render/scene.glsl>

// General layout rule declarations
layout(local_size_x_id = 0, local_size_y_id = 1) in;
layout(std140) uniform;
layout(std430) buffer;

// Specialization constant declarations
layout(constant_id = 2) const uint max_depth = 4;     // Maximum path depth
layout(constant_id = 3) const bool is_query  = false; // Whether path query mode is eanbled

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_sensor {
  mat4  full_trf;
  mat4  proj_trf;
  mat4  view_trf;
  uvec2 film_size; 
} buff_sensor;
layout(binding = 1) uniform b_buff_query {
  vec3 origin;    /* padd to 16 bytes */ uint p0;
  vec3 direction; /* padd to 16 bytes */ uint p1;
  uint n_paths; 
} buff_query;
layout(binding = 2) uniform b_buff_sampler_state {
  uint spp_per_iter;
  uint spp_curr;
} buff_sampler_state;
layout(binding = 3) uniform b_buff_objects {
  uint n;
  ObjectInfo data[max_supported_objects];
} buff_objects;
layout(binding = 4) uniform b_buff_meshes {
  uint n;
  MeshInfo data[max_supported_meshes];
} buff_meshes;
layout(binding = 5) uniform b_buff_textures {
  TextureInfo data[max_supported_textures];
} buff_textures;
layout(binding = 6) uniform b_buff_emitters {
  uint n;
  EmitterInfo data[max_supported_objects];
} buff_emitters;
layout(binding = 7) restrict readonly buffer b_buff_barycentrics {
  BarycentricInfo data[max_supported_objects];
} buff_barycentrics;
layout(binding = 8) uniform b_buff_wvls_distr {
  float func_sum;
  float func[wavelength_samples];
  float cdf[wavelength_samples + 1];
} buff_wvls_distr;
layout(binding = 9) uniform b_buff_emitters_distr {
  float func_sum;
  float func[max_supported_emitters];
  float cdf[max_supported_emitters + 1];
} buff_emitters_distr;

// Storage buffer declarations
layout(binding = 0) restrict readonly buffer b_buff_bvhs_node { BVHNodePack  data[]; } buff_bvhs_node;
layout(binding = 1) restrict readonly buffer b_buff_bvhs_prim { MeshPrimPack data[]; } buff_bvhs_prim;
layout(binding = 2) restrict readonly buffer b_buff_mesh_vert { MeshVertPack data[]; } buff_mesh_vert;
layout(binding = 3) restrict readonly buffer b_buff_mesh_elem { uvec3        data[]; } buff_mesh_elem;

// Texture/image units, ergo samplers and output images
layout(binding = 0)          uniform sampler2DArray   b_txtr_1f; // Alpha texture atlas
layout(binding = 1)          uniform sampler2DArray   b_txtr_3f; // RGB texture atlas
layout(binding = 2)          uniform sampler2DArray   b_bary_4f; // Uplifting weight atlas
layout(binding = 3)          uniform sampler1DArray   b_spec_4f; // Uplifting spectral atlas
layout(binding = 4)          uniform sampler1DArray   b_illm_1f; // Illuminant function data, 1 component
layout(binding = 5)          uniform sampler1DArray   b_cmfs_3f; // Observer function data, 3 components
layout(binding = 0, rgba32f) uniform restrict image2D b_film;    // Target film, averaged over frames

// Shared memory declarations
shared ObjectInfo      s_objc_info[max_supported_objects];
shared EmitterInfo     s_emtr_info[max_supported_objects];
shared BarycentricInfo s_bary_info[max_supported_objects];
shared MeshInfo        s_mesh_info[max_supported_meshes];

// Traversal stack lives in shared memory
// Object and emitter data comes from shared memory
// Texture data comes from uniform buffers and samplers
// Wavelength/emitter sampling distributions draw from uniform buffers
// Part of mesh data comes from storage buffers, part from shared memory
declare_scene_traversal_stack(8); 
declare_scene_object_data(s_objc_info, buff_objects.n);
declare_scene_emitter_data(s_emtr_info, buff_emitters.n);
declare_scene_reflectance_data(s_bary_info, b_bary_4f, b_spec_4f);
declare_scene_mesh_data(buff_mesh_vert.data, buff_mesh_elem.data, 
                        buff_bvhs_prim.data, buff_bvhs_node.data,
                        s_mesh_info, buff_meshes.n);
declare_distr_sampler(wavelength, buff_wvls_distr, wavelength_samples)
declare_distr_sampler(emitters, buff_emitters_distr, max_supported_emitters)

// The following includes rely on above buffers/samplers and are included last
#include <render/brdf.glsl>
#include <render/emitter.glsl>
#include <render/intersect.glsl>
#include <render/surface.glsl>

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < buff_objects.n; i += gl_WorkGroupSize.x) {
    s_objc_info[i] = buff_objects.data[i];
  }
  for (uint i = gl_LocalInvocationID.x; i < buff_objects.n; i += gl_WorkGroupSize.x) {
    s_bary_info[i] = buff_barycentrics.data[i];
  }
  for (uint i = gl_LocalInvocationID.x; i < buff_meshes.n; i += gl_WorkGroupSize.x) {
    s_mesh_info[i] = buff_meshes.data[i];
  }
  for (uint i = gl_LocalInvocationID.x; i < buff_emitters.n; i += gl_WorkGroupSize.x) {
    s_emtr_info[i] = buff_emitters.data[i];
  }
  memoryBarrierShared();
  barrier();
}

SamplerState load_state(uint spp_iter) {
  // Initial sample state is seeded from pixel index, and rotated by multiplication
  uint invoc_state = 1 
                   + gl_GlobalInvocationID.x 
                   + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;
  return invoc_state * (1 + buff_sampler_state.spp_curr + spp_iter);
}

vec3 sample_colsys(in uint colsys_i, in float wvl) {
  // TODO sample by observer data instead
  return texture(b_cmfs_3f, vec2(wvl, colsys_i)).xyz; // TODO fix integration through exposure
}

mat4x3 sample_colsys(in uint colsys_i, in vec4 wvl) {
  mat4x3 csys;
  for (uint i = 0; i < 4; ++i)
    csys[i] = sample_colsys(colsys_i, wvl[i]);
  return csys;
}

Ray ray_from_sensor(in ivec2 i, in vec2 sample_2d) {
  // Get necessary sensor information
  float tan_y    = 1.f / buff_sensor.proj_trf[1][1];
  float aspect   = float(buff_sensor.film_size.x) / float(buff_sensor.film_size.y);
  mat4  view_inv = inverse(buff_sensor.view_trf);

  // Get pixel center in [-1, 1]
  // vec2 xy = (vec2(i) + 0.5) / vec2(buff_sensor.film_size);
  vec2 xy = (vec2(i) + sample_2d) / vec2(buff_sensor.film_size);
  xy = (xy - .5f) * 2.f;
  
  // Generate camera ray
  Ray ray;
  ray.o = (view_inv * vec4(0, 0, 0, 1)).xyz;
  ray.d = normalize((view_inv * vec4(xy.x * tan_y * aspect, xy.y * tan_y, -1, 0)).xyz);
  ray.t = FLT_MAX;

  return ray;
}

Ray ray_from_query() {
  return init_ray(buff_query.origin, buff_query.direction);
}

float rotate_sample_1d(in float sample_1d, in uint i, in uint n) {
  return mod(sample_1d + float(i) / float(n), 1.f);
}

float mis_balance(in float pdf_a, in float pdf_b) {
  return pdf_a / (pdf_a + pdf_b);
}

float mis_power(in float pdf_a, in float pdf_b) {
  pdf_a *= pdf_a;
  pdf_b *= pdf_b;
  return pdf_a / (pdf_a + pdf_b);
}

// Sample radiance along ray and wavelengths
vec4 Li(in Ray ray, in vec4 wvls, in SamplerState ss) {
  // Path throughput information; we track 4 wavelengths simultaneously
  vec4  radiance        = vec4(0.f);
  vec4  throughput      = vec4(1.f);
  float prev_bsdf_pdf   = 1.f;
  bool  prev_bsdf_delta = true;
  
  // Iterate up to maximum depth
  for (uint depth = 0; depth < max_depth; ++depth) {
    // If the ray misses, terminate current path
    if (!scene_intersect(ray))
      break;

    // If no surface object is visible, terminate current path
    SurfaceInfo si = get_surface_info(ray);
    if (!is_valid(si))
      break;

    // If an emissive object is hit directly, add contribution to path
    if (is_emitter(si)) {
      PositionSample ps = get_position_sample(si);
      vec4           L  = eval_emitter(ps, wvls);

      float emtr_pdf = prev_bsdf_delta ? 0.f : pdf_emitters(ps);
      float weight   = mis_power(prev_bsdf_pdf, emtr_pdf);
      
      radiance += throughput * L * weight;
    }

    // Sample BRDF at position
    BRDFInfo brdf = get_brdf(si, wvls);
    
    // Direct illumination sampling;
    {
      // Generate position sample on emitter
      PositionSample ps       = sample_emitters(si, next_3d(ss));
      float          bsdf_pdf = pdf_brdf(brdf, si, ps.d);
      
      // If the sample position has potential throughput, 
      // evaluate a ray towards the position  
      if (ps.pdf != 0.f && bsdf_pdf != 0.f && dot(ps.d, si.sh.n) > 0.f) {
        Ray ray = ray_towards_point(si, ps.p);
        if (!scene_intersect_any(ray)) {
          // On a success, add contribution to path
          vec4 L = eval_emitter(ps, wvls) / ps.pdf;
          vec4 f = eval_brdf(brdf, si, ps.d);

          float weight = mis_power(ps.pdf, prev_bsdf_pdf * bsdf_pdf);
          radiance    += throughput * f * L * weight;
        }
      }
    }

    // BRDF sampling; 
    {
      BRDFSample bs = sample_brdf(brdf, next_2d(ss), si);
      if (bs.pdf == 0.f)
        break;
      
      // Update throughput
      throughput *= bs.f;
      if (all(iszero(throughput)))
        break;

      // Store previous BRDF information for MIS
      prev_bsdf_pdf   = bs.pdf;
      prev_bsdf_delta = bs.is_delta;

      // Generate next scene ray
      ray = ray_towards_direction(si, bs.wo);
    }

    // TODO RR goes here
    // ...
  } // for (uint depth)

  return radiance;
}

void main() {
  load_shared();

  // Clamp invocations to requested size
  if (is_query) {
    guard(gl_GlobalInvocationID.x < buff_query.n_paths);
  } else {
    guard(all(lessThan(ivec2(gl_GlobalInvocationID.xy), buff_sensor.film_size)));
  }

  vec3 output_color = vec3(0);
  for (uint spp_iter = 0; spp_iter < buff_sampler_state.spp_per_iter; ++spp_iter) {
    // Initialize sampler state
    SamplerState ss = load_state(spp_iter);

    // Generate ray/wavelength samples
    vec2  ray_sample = next_2d(ss);
    float wvl_sample = next_1d(ss);

    // Generate sensor/query ray
    Ray ray = is_query
            ? ray_from_query()
            : ray_from_sensor(ivec2(gl_GlobalInvocationID.xy), ray_sample);

    // Generate wavelengths; stratified sample passed through inverse cdf
    vec4 wvls, wvls_pdfs;
    for (uint i = 0; i < 4; ++i) {
      // Pass stratified wavelength sample through inverse cdf
      DistributionSampleContinuous ds = sample_wavelength_continuous(rotate_sample_1d(wvl_sample, i, 4));
      wvls[i]      = ds.f;
      wvls_pdfs[i] = ds.pdf;
    }

    // Sample incident radiance along ray for given wavelengths
    vec4 L = Li(ray, wvls, ss) / wvls_pdfs;

    // Integrate over color system and add to output color
    output_color += sample_colsys(0, wvls) * L;
  } // for (uint spp_iter)

  // Store output
  if (is_query) {
    // ...
  } else {
    // Add prior accumulated average from image
    if (buff_sampler_state.spp_curr > 0) {
      vec3 prev_color = imageLoad(b_film, ivec2(gl_GlobalInvocationID.xy)).xyz;
      output_color = prev_color
            + (output_color - prev_color)
            / float(buff_sampler_state.spp_curr + buff_sampler_state.spp_per_iter);
    }
    
    // Store updated image value and sample state
    imageStore(b_film, ivec2(gl_GlobalInvocationID.xy), vec4(output_color, 1));
  }
}