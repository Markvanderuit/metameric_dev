#include <preamble.glsl>
#include <guard.glsl>
#include <bvh.glsl>
#include <gbuffer.glsl>
#include <math.glsl>
#include <random_uniform.glsl>
#include <spectrum.glsl>
#include <scene.glsl>
#include <distribution.glsl>

// General layout rule declarations
layout(local_size_x = 16, local_size_y = 16) in;
layout(std140) uniform;
layout(std430) buffer;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_sensor {
  mat4  full_trf;
  mat4  proj_trf;
  mat4  view_trf;
  uvec2 film_size; 
} buff_sensor;
layout(binding = 1) uniform b_buff_sampler_state {
  uint spp_per_iter;
  uint spp_curr;
} buff_sampler_state;
layout(binding = 2) uniform b_buff_objects {
  uint n;
  ObjectInfo data[max_supported_objects];
} buff_objects;
layout(binding = 3) uniform b_buff_meshes {
  uint n;
  MeshInfo data[max_supported_meshes];
} buff_meshes;
layout(binding = 4) uniform b_buff_textures {
  TextureInfo data[max_supported_textures];
} buff_textures;
layout(binding = 5) uniform b_buff_emitters {
  uint n;
  EmitterInfo data[max_supported_objects];
} buff_emitters;
layout(binding = 6) uniform b_buff_wvls_distr {
  float func_sum;
  float func[wavelength_samples];
  float cdf[wavelength_samples + 1];
} buff_wvls_distr;

declare_distr_sampler(wavelength, buff_wvls_distr)

// Storage buffer declarations
layout(binding = 0) restrict buffer b_buff_sampler_data {
  uint data[];
} buff_sampler_data;
layout(binding = 1) restrict readonly buffer b_buff_bvhs_node {
  BVHNodePack data[];
} buff_bvhs_node;
layout(binding = 2) restrict readonly buffer b_buff_bvhs_prim {
  BVHPrimPack data[];
} buff_bvhs_prim;
layout(binding = 3) restrict readonly buffer b_buff_mesh_vert {
  BVHVertPack data[];
} buff_mesh_vert;
layout(binding = 4) restrict readonly buffer b_buff_mesh_elem {
  uvec3 data[];
} buff_mesh_elem;
layout(binding = 5) restrict readonly buffer b_buff_weights {
  AtlasLayout data[max_supported_objects];
} buff_weights;

// Texture unit, ergo sampler declarations
layout(binding = 0) uniform usampler2D     b_gbuffer; // G-buffer pack
layout(binding = 1) uniform sampler2DArray b_txtr_1f; // Alpha texture atlas
layout(binding = 2) uniform sampler2DArray b_txtr_3f; // RGB texture atlas
layout(binding = 3) uniform sampler2DArray b_bary_4f; // Uplifting weight atlas
layout(binding = 4) uniform sampler1DArray b_spec_4f; // Uplifting spectral atlas
layout(binding = 5) uniform sampler1DArray b_illm_1f; // Illuminant function data, 1 component
layout(binding = 6) uniform sampler1DArray b_cmfs_3f; // Observer function data, 3 components

// Image unit, output declaration
layout(binding = 0, rgba32f) uniform restrict image2D b_film;

// Shared memory declarations
shared ObjectInfo  s_objc_info[max_supported_objects];
shared EmitterInfo s_emtr_info[max_supported_objects];
shared MeshInfo    s_mesh_info[max_supported_meshes];
shared uint        s_stack[gl_WorkGroupSize.x * gl_WorkGroupSize.y][16];

// Define names of scene buffers to replace preproc in surface.glsl
// to work around glsl's lack of ssbo argument passing
#define srfc_buff_prim      buff_bvhs_prim.data
#define srfc_buff_vert      buff_mesh_vert.data
#define srfc_buff_elem      buff_mesh_elem.data
#define srfc_buff_objc_info s_objc_info
#define srfc_buff_mesh_info s_mesh_info
#include <surface.glsl>

// Define names of scene buffers to replace preproc in intersect.glsl
// to work around glsl's lack of ssbo argument passing
#define isct_n_objects      buff_objects.n
#define isct_n_emitters     buff_emitters.n
#define isct_stack          s_stack[gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x]
#define isct_buff_objc_info s_objc_info
#define isct_buff_emtr_info s_emtr_info
#define isct_buff_bvhs_info s_mesh_info
#define isct_buff_bvhs_node buff_bvhs_node.data
#define isct_buff_bvhs_prim buff_bvhs_prim.data
#include <intersect.glsl>
#include <emitter.glsl>

// Define names of scene buffers to replace preproc in brdf.glsl
// to work around glsl's lack of ssbo argument passing
#define brdf_buff_objc_info s_objc_info
#define brdf_buff_bary_info buff_weights.data
#define brdf_txtr_bary      b_bary_4f
#define brdf_txtr_spec      b_spec_4f
#include <brdf.glsl>

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < buff_objects.n; i += gl_WorkGroupSize.x) {
    s_objc_info[i] = buff_objects.data[i];
  }
  for (uint i = gl_LocalInvocationID.x; i < buff_meshes.n; i += gl_WorkGroupSize.x) {
    s_mesh_info[i] = buff_meshes.data[i];
  }
  for (uint i = gl_LocalInvocationID.x; i < buff_emitters.n; i += gl_WorkGroupSize.x) {
    s_emtr_info[i] = buff_emitters.data[i];
  }
  memoryBarrierShared();
  barrier();
}

uint load_state() {
  // Initial sample state is seeded from pixel index, and rotated by multiplication
  uint invoc_state = 1 
                   + gl_GlobalInvocationID.x 
                   + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;
  return invoc_state * (1 + buff_sampler_state.spp_curr);
}

vec3 sample_colsys(in uint colsys_i, in float wvl) {
  // TODO sample by observer data instead
  return texture(b_cmfs_3f, vec2(wvl, colsys_i)).xyz; // TODO fix integration through exposure
}

mat4x3 sample_colsys(in uint colsys_i, in vec4 wvl) {
  mat4x3 csys;
  for (uint i = 0; i < 4; ++i)
    csys[i] = sample_colsys(colsys_i, wvl[i]);
  return csys;
}

vec4 eval_env(in vec3 dir, in vec4 wvls) {
  return vec4(0); // vec4(max(0.f, dot(dir, normalize(vec3(0, 1, 0))))) * eval_emitter(0, wvls);
}

Ray ray_towards_direction(in SurfaceInfo si, in vec3 d) {
  Ray ray;

  ray.o = surface_offset(si, d);
  ray.d = d;
  ray.t = FLT_MAX;
  
  return ray;
}

Ray ray_towards_point(in SurfaceInfo si, in vec3 p) {
  Ray ray;

  ray.o = surface_offset(si, p - si.p);
  ray.d = p - ray.o;
  ray.t = length(ray.d);
  ray.d /= ray.t;
  ray.t *= (1.f - M_RAY_EPS * 10.f);

  return ray;
}

Ray ray_from_sensor(in ivec2 i, in vec2 sample_2d) {
  // Get necessary sensor information
  float tan_y    = 1.f / buff_sensor.proj_trf[1][1];
  float aspect   = float(buff_sensor.film_size.x) / float(buff_sensor.film_size.y);
  mat4  view_inv = inverse(buff_sensor.view_trf);

  // Get pixel center in [-1, 1]
  // vec2 xy = (vec2(i) + 0.5) / vec2(buff_sensor.film_size);
  vec2 xy = (vec2(i) + sample_2d) / vec2(buff_sensor.film_size);
  xy = (xy - .5f) * 2.f;
  
  // Generate camera ray
  Ray ray;
  ray.o = (view_inv * vec4(0, 0, 0, 1)).xyz;
  ray.d = normalize((view_inv * vec4(xy.x * tan_y * aspect, xy.y * tan_y, -1, 0)).xyz);
  ray.t = FLT_MAX;

  return ray;
}

const float exposure  = 1.f;
const uint  max_depth = 2;

float rotate_sample_1d(in float sample_1d, in uint i, in uint n) {
  return mod(sample_1d + float(i) / float(n), 1.f);
}

float mis_balance(in float pdf_a, in float pdf_b) {
  return pdf_a / (pdf_a + pdf_b);
}

float mis_power(in float pdf_a, in float pdf_b) {
  pdf_a *= pdf_a;
  pdf_b *= pdf_b;
  return pdf_a / (pdf_a + pdf_b);
}

// Sample radiance along ray and wavelengths
vec4 Li(in Ray ray, in vec4 wvls, in uint state, inout vec3 debug_color) {
  // Path throughput information; we track 4 wavelengths simultaneously
  vec4  radiance   = vec4(0.f);
  vec4  throughput = vec4(1.f);
  float bsdf_pdf   = 1.f;

  SurfaceInfo si;

  // Iterate up to maximum depth
  for (uint depth = 0; depth < max_depth; ++depth) {
    // If the ray misses, terminate current path
    if (!ray_intersect_scene(ray))
      break;

    // If an emissive object is hit directly, terminate current path
    if (hit_emitter(ray)) {
      EmitterInfo em = s_emtr_info[ray_get_emitter(ray)];
      vec4 em_value = eval_emitter(em, wvls, vec3(0));
      if (depth == 0) {
        // On direct hit, return emissive value
        radiance = em_value;
      } else {
        // On secondary hit, apply mis
        float em_pdf = pdf_emitter(em, si, ray_get_position(ray));
        float weight = mis_power(bsdf_pdf, em_pdf);
        if (em_pdf != 0.f)
          radiance += throughput * em_value * weight;
      }

      // Is this not necessary?
      break;
    }

    // If no surface object is visible, terminate current path
    si = get_surface_info(ray);
    if (!is_valid(si))
      break;

    {
      // ObjectInfo object_info = srfc_buff_objc_info[si.object_i];
      // MeshInfo mesh_info     = srfc_buff_mesh_info[object_info.mesh_i];
      // BVHPrim prim           = unpack(srfc_buff_prim[mesh_info.prims_offs + si.prim_i]);
      // // debug_color = vec3(float(si.prim_i) / float(mesh_info.prims_size));
      // vec3 n = cross(prim.v1.p - prim.v0.p, prim.v2.p - prim.v1.p);
      // n = (object_info.trf_mesh * vec4(n, 0)).xyz;
      // n = normalize(n);
      // ray.d = normalize(ray.d);
      // if (dot(n, ray.d) >= 0) {
      //   n = -n;
      // }
      // debug_color = si.p;
    }
    
    /* // If object back was hit, terminate current path
    if (frame_cos_theta(si.wi) < 0)
      break; */

    // Test if geometric/shading normals are aligned
    /* if (dot(ray.d, si.sh.n) * frame_cos_theta(si.wi) >= 0)
      break; */

    // Sample BRDF at position
    BRDF brdf = get_surface_brdf(si, wvls);
    
    // Direct illumination sampling;
    {
      // Generate emitter sample position, and ray twards position
      EmitterInfo   em = s_emtr_info[0]; // Pick emitter from cdf instead
      EmitterSample es = sample_emitter(em, si, wvls, next_2d(state));
      Ray        e_ray = ray_towards_point(si, es.p);
      vec4           f = eval_brdf(brdf, si, e_ray.d);
      
      if (es.pdf != 0.f && !all(iszero(f)) && dot(e_ray.d, si.sh.n) > 0.f) {
        // If ray evaluates no hit, add contribution to path
        if (!ray_intersect_any(e_ray)) {
          float weight = mis_power(es.pdf, bsdf_pdf * pdf_brdf(brdf, si, e_ray.d));
          radiance += throughput * f * es.L * weight;
        }
      }

      debug_color = vec3(1.f / sdot(es.p - si.p));
    }

    // BRDF sampling; 
    {
      // If BRDF goes dark, terminate path
      BRDFSample bs = sample_brdf(brdf, next_2d(state), si);
      if (bs.pdf == 0.f)
        break;
      
      if (dot(si.sh.n, bs.wo) <= 0)
        break;
      
      // Update throughput
      throughput *= bs.f;
      bsdf_pdf    = bs.pdf; // store previous brdf in case emitter is hit

      // Generate next scene ray
      ray = ray_towards_direction(si, bs.wo);
    }

    // TODO RR goes here
    // ...
  } // for (uint depth)

  return radiance;
}

void main() {
  load_shared();

  // 2D image coordinates; clamp invocations to image size
  const ivec2 i = ivec2(gl_GlobalInvocationID.xy);
  guard(all(lessThan(i, buff_sensor.film_size)));

  // Initialize sampler state
  uint state = load_state();

  // Generate initial sensor ray
  Ray ray = ray_from_sensor(i, next_2d(state));

  // Generate path wavelengths
  float wvl_sample = next_1d(state);
  vec4 wvls, wvl_pdfs;
  for (uint i = 0; i < 4; ++i) {
    // Pass stratified wavelength sample through inverse cdf
    // float wvl_rotated = rotate_sample_1d(wvl_sample, i, 4);
    // DistributionSample ds = sample_wavelength(wvl_rotated);
    // wvls[i]     = ds.f;
    // wvl_pdfs[i] = ds.pdf;

    // Naive alternative
    // wvls[i]     = next_1d(state);
    // wvl_pdfs[i] = 1.f;

    // Fixed wavelength
    wvls[i]     = 0.5;
    wvl_pdfs[i] = 1.f;
  }

  vec3 debug_color = vec3(0);

  // Evaluate ray/wavelength pair
  vec4 L = Li(ray, wvls, state, debug_color) / wvl_pdfs;

  // Integrate radiance over color system to get color
  vec3 value = sample_colsys(0, wvls) * exposure * L;
      //  value = debug_color;

  // Add prior accumulated average
  if (buff_sampler_state.spp_curr > 0) {
    vec3 prev = imageLoad(b_film, ivec2(i)).xyz;
    value = prev
          + (value - prev)
          / float(buff_sampler_state.spp_curr + buff_sampler_state.spp_per_iter);
  }

  // Store updated image value and sample state
  imageStore(b_film, i, vec4(value, 1));
}