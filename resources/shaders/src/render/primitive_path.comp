#include <preamble.glsl>
#include <guard.glsl>
#include <bvh.glsl>
#include <gbuffer.glsl>
#include <math.glsl>
#include <random_uniform.glsl>
#include <spectrum.glsl>
#include <scene.glsl>

// General layout rule declarations
layout(local_size_x = 16, local_size_y = 16) in;
layout(std140) uniform;
layout(std430) buffer;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_sensor {
  mat4  full_trf;
  mat4  proj_trf;
  mat4  view_trf;
  uvec2 film_size; 
} buff_sensor;
layout(binding = 1) uniform b_buff_sampler_state {
  uint spp_per_iter;
  uint spp_curr;
} buff_sampler_state;
layout(binding = 2) uniform b_buff_objects {
  uint n;
  ObjectInfo data[max_supported_objects];
} buff_objects;
layout(binding = 3) uniform b_buff_meshes {
  uint n;
  MeshInfo data[max_supported_meshes];
} buff_meshes;
layout(binding = 4) uniform b_buff_textures {
  TextureInfo data[max_supported_textures];
} buff_textures;

// Storage buffer declarations
layout(binding = 0) restrict buffer b_buff_sampler_data {
  uint data[];
} buff_sampler_data;
layout(binding = 1) restrict readonly buffer b_buff_bvhs_node {
  BVHNodePack data[];
} buff_bvhs_node;
layout(binding = 2) restrict readonly buffer b_buff_bvhs_prim {
  BVHPrimPack data[];
} buff_bvhs_prim;
layout(binding = 3) restrict readonly buffer b_buff_mesh_vert {
  BVHVertPack data[];
} buff_mesh_vert;
layout(binding = 4) restrict readonly buffer b_buff_mesh_elem {
  uvec3 data[];
} buff_mesh_elem;
layout(binding = 5) restrict readonly buffer b_buff_weights {
  AtlasLayout data[max_supported_objects];
} buff_weights;

// Texture unit, ergo sampler declarations
layout(binding = 0) uniform usampler2D     b_gbuffer; // G-buffer pack
layout(binding = 1) uniform sampler2DArray b_txtr_1f; // Alpha texture atlas
layout(binding = 2) uniform sampler2DArray b_txtr_3f; // RGB texture atlas
layout(binding = 3) uniform sampler2DArray b_bary_4f; // Uplifting weight atlas
layout(binding = 4) uniform sampler1DArray b_spec_4f; // Uplifting spectral atlas
layout(binding = 5) uniform sampler1DArray b_illm_1f; // Illuminant function data, 1 component
layout(binding = 6) uniform sampler1DArray b_cmfs_3f; // Observer function data, 3 components

// Image unit, output declaration
layout(binding = 0, rgba32f) uniform restrict image2D b_film;

// Shared memory declarations
shared ObjectInfo s_objc_info[max_supported_objects];
shared MeshInfo   s_mesh_info[max_supported_meshes];
shared uint       s_stack[gl_WorkGroupSize.x * gl_WorkGroupSize.y][16];

// Define names of scene buffers to replace preproc in intersect.glsl
// to work around glsl's lack of ssbo argument passing
#define isct_n_objects      buff_objects.n
#define isct_stack          s_stack[gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x]
#define isct_buff_objc_info s_objc_info
#define isct_buff_bvhs_info s_mesh_info
#define isct_buff_bvhs_node buff_bvhs_node.data
#define isct_buff_bvhs_prim buff_bvhs_prim.data
#include <intersect.glsl>

// Define names of scene buffers to replace preproc in surface.glsl
// to work around glsl's lack of ssbo argument passing
#define srfc_buff_prim      buff_bvhs_prim.data
#define srfc_buff_vert      buff_mesh_vert.data
#define srfc_buff_elem      buff_mesh_elem.data
#define srfc_buff_objc_info s_objc_info
#define srfc_buff_mesh_info s_mesh_info
#include <surface_from_gbuffer.glsl>

// Define names of scene buffers to replace preproc in brdf.glsl
// to work around glsl's lack of ssbo argument passing
#define brdf_buff_objc_info s_objc_info
#define brdf_buff_bary_info buff_weights.data
#define brdf_txtr_bary      b_bary_4f
#define brdf_txtr_spec      b_spec_4f
#include <brdf.glsl>

// Hardcoded value for now
vec3 hardcoded_lpos = vec3(6, 4, 2);

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < buff_objects.n; i += gl_WorkGroupSize.x) {
    s_objc_info[i] = buff_objects.data[i];
  }
  for (uint i = gl_LocalInvocationID.x; i < buff_meshes.n; i += gl_WorkGroupSize.x) {
    s_mesh_info[i] = buff_meshes.data[i];
  }
  memoryBarrierShared();
  barrier();
}

uint load_state() {
  // Initial sample state is seeded from pixel index
  // Initialize sampler state, or load it if the frame is cumulative
  // uint i = gl_GlobalInvocationID.y * buff_sensor.film_size.x + gl_GlobalInvocationID.x;
  
  
  uvec2 block = gl_GlobalInvocationID.xy % 64;
  uint  state = block.y * 64 + block.x;
  state *= (buff_sampler_state.spp_curr + 1);
  return state;

  // if (buff_sampler_state.spp_curr != 0)
  //   return buff_sampler_data.data[i];
  // else
  //   return i;

    // return (gl_GlobalInvocationID.xy % 64) * (buff_sampler_state.spp_curr + 1);
    // return i;
  //   return gl_GlobalInvocationID.xy;
}

void store_state(in uint state) {
  uint i = gl_GlobalInvocationID.y * buff_sensor.film_size.x + gl_GlobalInvocationID.x;
  buff_sampler_data.data[i] = state;
}

SurfaceInfo sample_gbuffer(in uvec2 i) {
  uvec4 v = texelFetch(b_gbuffer, ivec2(i), 0);
  return get_surface_info(unpack_gbuffer_ray(v));
}

vec3 sample_colsys(in uint colsys_i, in float wvl) {
  // TODO sample by observer data instead
  return texture(b_cmfs_3f, vec2(wvl, colsys_i)).xyz/*  *
         texture(b_illm_1f, vec2(wvl, colsys_i)).x   * .01f */; // TODO fix integration through exposure
}

mat4x3 sample_colsys(in uint colsys_i, in vec4 wvl) {
  mat4x3 csys;
  for (uint i = 0; i < 4; ++i)
    csys[i] = sample_colsys(colsys_i, wvl[i]);
  return csys;
}

float sample_emitter(in uint emitter_i, in float wvl) {
  return texture(b_illm_1f, vec2(wvl, emitter_i)).x;
}

vec4 sample_emitter(in uint emitter_i, in vec4 wvl) {
  vec4 v;
  for (uint i = 0; i < 4; ++i)
    v[i] = sample_emitter(emitter_i, wvl[i]);
  return v;
}

/* // Offset epsilon copied from mitsuba3
vec3 gen_offset_p(in SurfaceInfo si, in vec3 d) {
  float mag = 1.f + hmax(abs(si.p)) + 1500.f * M_EPS;
  mag = dot(si.n, d) >= 0 ? mag : -mag;
  return fma(vec3(mag), si.n, si.p);
} */

void main() {
  load_shared();

  // 2D image coordinates; clamp invocations to image size
  const ivec2 i = ivec2(gl_GlobalInvocationID.xy);
  guard(all(lessThan(i, buff_sensor.film_size)));

  // Sampler state is based on 2d invocation index
  uint state = load_state();

  // Path throughput information
  // bool did_scatter = false; // TODO unused until emitters are added
  vec4 wavelengths = next_4d(state);
  vec4 radiance    = vec4(0.f);
  vec4 throughput  = vec4(1.f);
  vec4 p           = vec4(1.f / float(wavelength_samples));
  
  // Next path ray
  Ray ray;

  // Iterate up to maximum depth
  const uint max_depth = 8;
  for (uint depth = 0; depth < max_depth; ++depth) {
    // Obtain surface information, either from gbuffer or ray hit
    SurfaceInfo si;
    if (depth == 0) {
      si = sample_gbuffer(i);
    } else {
      ray_intersect_scene(ray);
      si = get_surface_info(ray);
    }

    // If no object is visible, terminate current path
    if (si.object_i == OBJECT_INVALID)
      break;

    // Sample BRDF at position
    BRDF brdf = get_surface_brdf(si, wavelengths);
    
    // If no throughput, terminate current path
    if (all(equal(brdf.r, vec4(0))))
      break;

    // Emitter sampling
    {
      // Generate emiter sample // TODO sample emitter
      vec3 lpos = hardcoded_lpos + next_3d(state) * 4.f - 2.f;

      // Generate shadow ray
      Ray shadow_ray;
      shadow_ray.d = lpos - si.p;
      shadow_ray.t = length(shadow_ray.d);
      shadow_ray.d /= shadow_ray.t;
      shadow_ray.o = si.p + 0.001f * si.n;

      // If no hit, add contribution
      if (!ray_intersect_any(shadow_ray)) {
        vec4 Le         = sample_emitter(0, wavelengths);
        float cos_theta = dot(si.ns, shadow_ray.d);
        if (cos_theta > 0)
          radiance += Le * throughput * brdf.r * cos_theta / p;
      }
    }

    // BSDF sampling
    {
      // Generate new ray // TODO sample brdf and not this junk
      ray.d = normalize(2.f * next_3d(state) - 1.f);
      ray.o = si.p + 0.001f * si.n;
      ray.t = FLT_MAX;

      float cos_theta = dot(si.ns, ray.d);
      if (cos_theta <= 0.f)
        break;

      throughput *= brdf.r * cos_theta;
    }
  } // for (uint depth)

  // Integrate radiance over color system to get color
  mat4x3 csys = sample_colsys(0, wavelengths) * 0.01f;
  vec3 value = csys * radiance;

  // Reweight with prior accumulated radiance
  if (buff_sampler_state.spp_curr != 0) {
    value += imageLoad(b_film, ivec2(i)).xyz * float(buff_sampler_state.spp_curr);
    value /= float(buff_sampler_state.spp_curr + buff_sampler_state.spp_per_iter);
  }

  // Store updated image value and sample state
  imageStore(b_film, i, vec4(value, 1));
  // store_state(state);
}