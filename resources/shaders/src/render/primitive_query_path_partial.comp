#include <preamble.glsl>
#include <math.glsl>
#include <spectrum.glsl>
#include <distribution.glsl>
#include <sampler/uniform.glsl>
#include <render/load.glsl>

// General layout rule declarations
layout(local_size_x_id = 0) in;
layout(std140) uniform;
layout(std430) buffer;

// Specialization constant declarations
layout(constant_id = 1) const uint max_depth = 4; // Maximum path depth

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_sensor {
  vec3 origin;    /* padd to 16 bytes */ uint p0;
  vec3 direction; /* padd to 16 bytes */ uint p1;
  uint n;         // Approximate nr. of paths to measure 
} buff_sensor;
layout(binding = 1) uniform b_buff_objects {
  uint n;
  ObjectInfo data[max_supported_objects];
} buff_objects;
layout(binding = 2) uniform b_buff_meshes {
  uint n;
  MeshInfo data[max_supported_meshes];
} buff_meshes;
layout(binding = 3) uniform b_buff_textures {
  TextureInfo data[max_supported_textures];
} buff_textures;
layout(binding = 4) uniform b_buff_emitters {
  uint n;
  EmitterInfo data[max_supported_objects];
} buff_emitters;
layout(binding = 5) restrict readonly buffer b_buff_barycentrics {
  BarycentricInfo data[max_supported_objects];
} buff_barycentrics;
layout(binding = 6) uniform b_buff_wvls_distr {
  float func_sum;
  float func[wavelength_samples];
  float cdf[wavelength_samples + 1];
} buff_wvls_distr;
layout(binding = 7) uniform b_buff_emitters_distr {
  float func_sum;
  float func[max_supported_emitters];
  float cdf[max_supported_emitters + 1];
} buff_emitters_distr;

// Storage buffer declarations
layout(binding = 0) restrict readonly buffer b_buff_bvhs_node { 
  BVHNodePack  data[]; 
} buff_bvhs_node;
layout(binding = 1) restrict readonly buffer b_buff_bvhs_prim { 
  MeshPrimPack data[]; 
} buff_bvhs_prim;
layout(binding = 2) restrict coherent buffer b_buff_path_data { 
  uint head;
  uint padd[3]; /* align head to 16 bytes */ 
  Path data[];
} buff_path_data;

// Texture/image units, ergo samplers and output images
layout(binding = 0) uniform sampler2DArray b_txtr_1f; // Alpha texture atlas
layout(binding = 1) uniform sampler2DArray b_txtr_3f; // RGB texture atlas
layout(binding = 2) uniform sampler2DArray b_bary_4f; // Uplifting weight atlas
layout(binding = 3) uniform sampler1DArray b_spec_4f; // Uplifting spectral atlas
layout(binding = 4) uniform sampler1DArray b_illm_1f; // Illuminant function data, 1 component
layout(binding = 5) uniform sampler1DArray b_cmfs_3f; // Observer function data, 3 components

// Shared memory declarations
shared ObjectInfo      s_objc_info[max_supported_objects];
shared EmitterInfo     s_emtr_info[max_supported_objects];
shared BarycentricInfo s_bary_info[max_supported_objects];
shared MeshInfo        s_mesh_info[max_supported_meshes];

// Traversal stack lives in shared memory
// Object and emitter data comes from shared memory
// Texture data comes from uniform buffers and samplers
// Wavelength/emitter sampling distributions draw from uniform buffers
// Color system spectra and illuminant spectra draw from sampler arrays
// Part of mesh data comes from storage buffers, part from shared memory
declare_scene_cmfs_data(b_cmfs_3f);
declare_scene_illuminant_data(b_illm_1f);
declare_scene_object_data(s_objc_info, buff_objects.n);
declare_scene_bvh_data(buff_bvhs_prim.data, buff_bvhs_node.data, s_mesh_info, buff_meshes.n);
declare_scene_emitter_data(s_emtr_info, buff_emitters.n);
declare_scene_reflectance_data(s_bary_info, b_bary_4f, b_spec_4f);
declare_scene_traversal_stack(8); 
declare_distr_sampler(wavelength, buff_wvls_distr, wavelength_samples)
declare_distr_sampler(emitters, buff_emitters_distr, max_supported_emitters)
declare_path_data(buff_path_data.head, buff_path_data.data);

// All includes from and in here rely on buffers/samplers to be declared
#include <render/tracking/partial.glsl>

void load_shared() {
  const uint iter = hprod(gl_WorkGroupSize.xyz);
  for (uint i = gl_LocalInvocationIndex; i < buff_objects.n; i += iter)  s_objc_info[i] = buff_objects.data[i];
  for (uint i = gl_LocalInvocationIndex; i < buff_objects.n; i += iter)  s_bary_info[i] = buff_barycentrics.data[i];
  for (uint i = gl_LocalInvocationIndex; i < buff_meshes.n; i += iter)   s_mesh_info[i] = buff_meshes.data[i];
  for (uint i = gl_LocalInvocationIndex; i < buff_emitters.n; i += iter) s_emtr_info[i] = buff_emitters.data[i];
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();

  // Clamp invocations to requested size
  guard(gl_GlobalInvocationID.x < buff_sensor.n);

  // Load sensor data
  RaySensor sensor = { buff_sensor.origin, buff_sensor.direction };

  // Target value
  vec3 measure = vec3(0);

  // Initialize sampler and generate sensor sample
  SamplerState state         = gl_GlobalInvocationID.x;
  SensorSample sensor_sample = sample_sensor(sensor, next_1d(state));

  // Sample incident radiance along ray for given wavelengths, weighted by probability
  // Discard return value
  /* vec4 L = */ Li(sensor_sample, state);

  /* // Integrate over color system and add to measure
  vec3 measure = sensor_apply(sensor_sample, L); */

  /* // Combine running average from film with measure
  vec3 pm = imageLoad(b_film, ivec2(gl_GlobalInvocationID.xy)).xyz;
  measure = pm
          + (measure - pm)
          / float(buff_sampler_state.spp_curr + buff_sampler_state.spp_per_iter);
  
  // Store updated measure to film
  imageStore(b_film, ivec2(gl_GlobalInvocationID.xy), vec4(measure, 1)); */
}