#include <preamble.glsl>
#include <bvh.glsl>
#include <gbuffer.glsl>
#include <math.glsl>
#include <sampler/uniform.glsl>
#include <spectrum.glsl>
#include <render/scene.glsl>

// General layout rule declarations
layout(local_size_x = 16, local_size_y = 16) in;
layout(std140) uniform;
layout(std430) buffer;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_sensor {
  mat4  full_trf;
  mat4  proj_trf;
  mat4  view_trf;
  uvec2 film_size; 
} buff_sensor;
layout(binding = 1) uniform b_buff_sampler_state {
  uint spp_per_iter;
  uint spp_curr;
} buff_sampler_state;
layout(binding = 2) uniform b_buff_objects {
  uint n;
  ObjectInfo data[max_supported_objects];
} buff_objects;
layout(binding = 3) uniform b_buff_meshes {
  uint n;
  MeshInfo data[max_supported_meshes];
} buff_meshes;
layout(binding = 4) uniform b_buff_textures {
  TextureInfo data[max_supported_textures];
} buff_textures;
layout(binding = 5) uniform b_buff_emitters {
  uint n;
  EmitterInfo data[max_supported_objects];
} buff_emitters;

// Storage buffer declarations
layout(binding = 0) restrict buffer b_buff_sampler_data {
  uint data[];
} buff_sampler_data;
layout(binding = 1) restrict readonly buffer b_buff_bvhs_node {
  BVHNodePack data[];
} buff_bvhs_node;
layout(binding = 2) restrict readonly buffer b_buff_bvhs_prim {
  BVHPrimPack data[];
} buff_bvhs_prim;
layout(binding = 3) restrict readonly buffer b_buff_mesh_vert {
  BVHVertPack data[];
} buff_mesh_vert;
layout(binding = 4) restrict readonly buffer b_buff_mesh_elem {
  uvec3 data[];
} buff_mesh_elem;
layout(binding = 5) restrict readonly buffer b_buff_barycentrics {
  BarycentricInfo data[max_supported_objects];
} buff_barycentrics;

// Texture/image units, ergo samplers and output images
layout(binding = 0)          uniform usampler2D       b_gbuffer; // G-buffer pack
layout(binding = 1)          uniform sampler2DArray   b_txtr_1f; // Alpha texture atlas
layout(binding = 2)          uniform sampler2DArray   b_txtr_3f; // RGB texture atlas
layout(binding = 3)          uniform sampler2DArray   b_bary_4f; // Uplifting weight atlas
layout(binding = 4)          uniform sampler1DArray   b_spec_4f; // Uplifting spectral atlas
layout(binding = 5)          uniform sampler1DArray   b_illm_1f; // Illuminant function data, 1 component
layout(binding = 6)          uniform sampler1DArray   b_cmfs_3f; // Observer function data, 3 components
layout(binding = 0, rgba32f) uniform restrict image2D b_film;    // Target film, averaged over frames

// Shared memory declarations
shared ObjectInfo  s_objc_info[max_supported_objects];
shared EmitterInfo s_emtr_info[max_supported_objects];
shared BarycentricInfo s_bary_info[max_supported_objects];
shared MeshInfo    s_mesh_info[max_supported_meshes];

// Part of mesh data comes from storage buffers, part
// comes from shared memory
declare_scene_mesh_data(buff_mesh_vert.data, 
                        buff_mesh_elem.data, 
                        buff_bvhs_prim.data, 
                        buff_bvhs_node.data,
                        s_mesh_info, buff_meshes.n);

// Traversal stack lives in shared memory, depth 16
declare_scene_traversal_stack(16);

// Object and emitter data come from shared memory
declare_scene_object_data(s_objc_info, buff_objects.n);
declare_scene_emitter_data(s_emtr_info, buff_emitters.n);
declare_scene_reflectance_data(s_bary_info, b_bary_4f, b_spec_4f);

#include <intersect.glsl>
#include <surface.glsl>
#include <brdf.glsl>

// Hardcoded value for now
vec3 hardcoded_lpos = vec3(10, 10, 10); // 10 * vec3(-1, 1, 1);

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < buff_objects.n; i += gl_WorkGroupSize.x) {
    s_objc_info[i] = buff_objects.data[i];
  }
  for (uint i = gl_LocalInvocationID.x; i < buff_objects.n; i += gl_WorkGroupSize.x) {
    s_bary_info[i] = buff_barycentrics.data[i];
  }
  for (uint i = gl_LocalInvocationID.x; i < buff_meshes.n; i += gl_WorkGroupSize.x) {
    s_mesh_info[i] = buff_meshes.data[i];
  }
  for (uint i = gl_LocalInvocationID.x; i < buff_meshes.n; i += gl_WorkGroupSize.x) {
    s_mesh_info[i] = buff_meshes.data[i];
  }
  memoryBarrierShared();
  barrier();
}

uint load_state() {
  // Initial sample state is seeded from pixel index
  // Initialize sampler state, or load it if the frame is cumulative
  uint i = gl_GlobalInvocationID.y * buff_sensor.film_size.x + gl_GlobalInvocationID.x;
  if (buff_sampler_state.spp_curr != 0)
    return buff_sampler_data.data[i];
  else
    return i;
}

void store_state(in uint state) {
  uint i = gl_GlobalInvocationID.y * buff_sensor.film_size.x + gl_GlobalInvocationID.x;
  buff_sampler_data.data[i] = state;
}

vec3 sample_colsys(in uint colsys_i, in float wvl) {
  // TODO sample by observer data instead
  return texture(b_cmfs_3f, vec2(wvl, colsys_i)).xyz *
         texture(b_illm_1f, vec2(wvl, colsys_i)).x   * .01f; // TODO fix integration through exposure
}

mat4x3 sample_colsys(in uint colsys_i, in vec4 wvl) {
  mat4x3 csys;
  for (uint i = 0; i < 4; ++i)
    csys[i] = sample_colsys(colsys_i, wvl[i]);
  return csys;
}

// Offset epsilon copied from mitsuba3
vec3 gen_offset_p(in SurfaceInfo si, in vec3 d) {
  float mag = 1.f + hmax(abs(si.p)) + 1500.f * M_EPS;
  mag = dot(si.n, d) >= 0 ? mag : -mag;
  return fma(vec3(mag), si.n, si.p);
}

bool test_visibility(inout uint state, in SurfaceInfo si) {
  vec3 lpos = hardcoded_lpos + next_3d(state) * 4.f - 2.f;
  
  Ray ray;
  ray.d = lpos - si.p;
  ray.t = length(ray.d);
  ray.d /= ray.t;
  ray.o = si.p + 0.001f * si.n;

  // Mistake; gbuffer normal is not geometric normal!
  // ray.o = gen_offset_p(si, ray.d);

  return !scene_intersect_any(ray);
}

Ray ray_from_sensor(in ivec2 i) {
  // Get necessary sensor information
  float tan_y    = 1.f / buff_sensor.proj_trf[1][1];
  float aspect   = float(buff_sensor.film_size.x) / float(buff_sensor.film_size.y);
  mat4  view_inv = inverse(buff_sensor.view_trf);

  // Get pixel center in [-1, 1]
  vec2 xy = (vec2(i) + 0.5) / vec2(buff_sensor.film_size);
  xy = (xy - .5f) * 2.f;
  
  // Generate camera ray
  Ray ray;
  ray.o = (view_inv * vec4(0, 0, 0, 1)).xyz;
  ray.d = normalize((view_inv * vec4(xy.x * tan_y * aspect, xy.y * tan_y, -1, 0)).xyz);
  ray.t = FLT_MAX;

  return ray;
}

void main() {
  // load_shared();

  // // 2D image coordinates; clamp invocations to image size
  // const ivec2 i = ivec2(gl_GlobalInvocationID.xy);
  // guard(all(lessThan(i, buff_sensor.film_size)));

  // // Initialize sampler state, or load it if the frame is cumulative
  // uint state = load_state();

  // // Obtain surface information from a first ray hit, by extracting data from a gbuffer
  // uvec4 v = texelFetch(b_gbuffer, ivec2(i), 0);
  // SurfaceInfo si = get_surface_info(unpack_gbuffer_ray(v), ray_from_sensor(ivec2(i)));

  // // If no object is visible, set to black and early-out
  // if (!is_valid(si)) {
  //   imageStore(b_film, i, vec4(0, 0, 0, 1));
  //   return;
  // }

  // // Load relevant info objects
  // AtlasLayout bary_layout = buff_weights.data[si.object_i];
  // ObjectInfo  object_info = buff_objects.data[si.object_i];

  // // Initialize image value, or load prior if the frame is cumulative
  // vec3 value = buff_sampler_state.spp_curr == 0 
  //            ? vec3(0)
  //            : imageLoad(b_film, ivec2(i)).xyz * float(buff_sampler_state.spp_curr);

  // if (test_visibility(state, si)) {
  //   PreliminaryBRDF pr = get_surface_brdf_preliminary(si);
    
  //   // Sample reflectance n times
  //   for (uint i = 0; i < buff_sampler_state.spp_per_iter; i ++) {
  //     vec4   wavelength = next_4d(state);
  //     BRDF   brdf       = get_surface_brdf(pr, wavelength);
  //     mat4x3 csys       = sample_colsys(0, wavelength);

  //     value += csys * brdf.r * float(wavelength_samples) / 4.f;
  //   }
  // }

  // // Reweight image value by actual nr. of samples
  // value /= float(buff_sampler_state.spp_curr + buff_sampler_state.spp_per_iter);
  
  // // Store updated image value and sample state
  // imageStore(b_film, i, vec4(value, 1));
  // store_state(state);
}