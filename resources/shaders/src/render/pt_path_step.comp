#include <preamble.glsl>
#include <guard.glsl>
#include <math.glsl>
#include <random_uniform.glsl>
#include <ray.glsl>
#include <bvh.glsl>
#include <scene.glsl>

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std140)             uniform;
layout(std430)             buffer;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_unif {
  mat4  view_inv;  // inverse(view);
  uvec2 view_size; // width, height of image
  float fovy_tan;  // tan(fov_y * .5f);
  float aspect;    // vec2(aspect, 1);
} buff_unif;

// Storage buffer declarations
layout(binding = 0) restrict readonly buffer b_buff_path_head   { uint n;             } buff_path_head;   // Size of work queue
layout(binding = 1) restrict          buffer b_buff_path_data   { PathInfo    data[]; } buff_path_data;   // Work path data
layout(binding = 2) restrict readonly buffer b_buff_extend_head { uint n;             } buff_extend_head; // Size of work queue
layout(binding = 3) restrict readonly buffer b_buff_extend_data { Ray         data[]; } buff_extend_data; // Work ray data
layout(binding = 4) restrict readonly buffer b_buff_bvhs_prim   { BVHPrimPack data[]; } buff_bvhs_prim;   // Packed surface primitives

// Image unit, output declaration
layout(binding = 0, rgba32f) uniform restrict image2D b_target_4f;

// Set name of surface primitive buffer, and include surface.glsl
#define srfc_buff_prim buff_bvhs_prim.data
#include <surface.glsl>

void main() {
  // Thread index is work index
  const uint i = gl_GlobalInvocationID.x;
  guard(i < buff_path_head.n);
  
  // Load active path info from buffer
  PathInfo pi = buff_path_data.data[i];

  // Path has restarted, generate necessary samples
  if (pi.depth == 0) {

  }

  // Get surface info at hit, based on last extension ray
  Ray ray = buff_extend_data.data[pi.ray_extend_i];
  SurfaceInfo si = get_surface_info(ray);

  // Get shadow ray information, if this is not the first pass
  if (pi.depth != 0) {
    // ...
  }
  
  // If a valid surface was hit, write surface position to path's associated pixel for now
  if (si.object_i != OBJECT_INVALID) {
    imageStore(b_target_4f, get_path_pixel(pi), vec4(si.p, 1));
  }
}