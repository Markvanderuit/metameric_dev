#include <preamble.glsl>
#include <math.glsl>
#include <spectrum.glsl>
#include <distribution.glsl>
#include <sampler/uniform.glsl>
#include <render/detail/path_types.glsl>
#include <render/detail/scene_types.glsl>
#include <render/load/bvh.glsl>
#include <render/load/tlas.glsl>
#include <render/load/cmfs.glsl>
#include <render/load/emitter.glsl>
#include <render/load/illuminant.glsl>
#include <render/load/object.glsl>
#include <render/load/reflectance.glsl>
#include <render/load/defaults.glsl>

// General layout rule declarations
layout(local_size_x_id = 0, local_size_y_id = 1) in;
layout(std140) uniform;
layout(std430) buffer;

// Specialization constant declarations
layout(constant_id = 2) const uint max_depth = 4;     // Maximum path depth
layout(constant_id = 3) const bool use_alpha = false; // On initial ray miss, return 0 alpha?
layout(constant_id = 4) const bool use_debug = false; // Override and enable debug queries

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_sensor {
  mat4  full_trf;
  mat4  proj_trf;
  mat4  view_trf;
  uvec2 film_size; 
} buff_sensor;
layout(binding = 1) uniform b_buff_sampler_state {
  uint spp_per_iter;
  uint spp_curr;
  uint pixel_checkerboard;
  uint pixel_curr;
} buff_sampler_state;
layout(binding = 2) uniform b_buff_objects {
  uint n;
  ObjectInfo data[met_max_objects];
} buff_objects;
layout(binding = 3) uniform b_buff_meshes {
  uint n;
  MeshInfo data[met_max_meshes];
} buff_meshes;
layout(binding = 4) uniform b_buff_emitters {
  uint n;
  EmitterInfo data[met_max_emitters];
} buff_emitters;
layout(binding = 5) uniform b_buff_scene {
  SceneInfo data;
} buff_scene;
layout(binding = 6) uniform b_buff_wvls_distr {
  float func_sum;
  float func[wavelength_samples];
  float cdf[wavelength_samples + 1];
} buff_wvls_distr;
layout(binding = 7) uniform b_buff_emitters_distr {
  float func_sum;
  float func[met_max_emitters];
  float cdf[met_max_emitters + 1];
} buff_emitters_distr;
layout(binding = 8) uniform b_buff_envmap_info {
  bool envm_is_present;
  uint envm_i;
} buff_envmap_info;

// Storage buffer declarations
layout(binding = 0) restrict readonly buffer b_buff_bvhs_node { BVHNodePack  data[]; } buff_bvhs_node;
layout(binding = 1) restrict readonly buffer b_buff_bvhs_prim { MeshPrimPack data[]; } buff_bvhs_prim;
layout(binding = 2) restrict readonly buffer b_buff_tlas_node { BVHNodePack  data[]; } buff_tlas_node;
layout(binding = 3) restrict readonly buffer b_buff_tlas_prim { uint         data[]; } buff_tlas_prim;
layout(binding = 4) restrict readonly buffer b_buff_coeffs {
  BarycentricInfo data[met_max_objects];
} buff_coeffs;

// Texture/image units, ergo samplers and output images
layout(binding = 2)          uniform sampler1DArray   b_illm_1f; // Illuminant function data, 1 component
layout(binding = 3)          uniform sampler1DArray   b_cmfs_3f; // Observer function data, 3 components
layout(binding = 4)          uniform sampler1DArray   b_bsis_1f; // Basis function data, 1 component
layout(binding = 5)          uniform usampler2DArray  b_coef_4f; // Coefficient data for spectral MESE
layout(binding = 0, rgba32f) uniform restrict image2D b_film;    // Target film, averaged over frames

// Shared memory declarations
shared ObjectInfo      s_objc_info[met_max_objects];
shared EmitterInfo     s_emtr_info[met_max_emitters];
shared BarycentricInfo s_bary_info[met_max_objects];
shared MeshInfo        s_mesh_info[met_max_meshes];

// Traversal stack lives in shared memory
// Object and emitter data comes from shared memory
// Texture data comes from uniform buffers and samplers
// Wavelength/emitter sampling distributions draw from uniform buffers
// Color system spectra and illuminant spectra draw from sampler arrays
// Part of mesh data comes from storage buffers, part from shared memory
declare_scene_traversal_stack(6); 
declare_scene_tlas_stack(4); 
declare_distr_sampler(wavelength, buff_wvls_distr, wavelength_samples)
declare_distr_sampler(emitters, buff_emitters_distr, met_max_emitters)
declare_scene_cmfs_data(b_cmfs_3f);
declare_scene_illuminant_data(b_illm_1f);
declare_scene_object_data(s_objc_info, buff_objects.n);
declare_scene_bvh_data(buff_bvhs_prim.data, buff_bvhs_node.data, s_mesh_info, buff_meshes.n);
declare_scene_tlas_data(buff_tlas_prim.data, buff_tlas_node.data, buff_scene.data);
declare_scene_emitter_data(s_emtr_info, buff_emitters.n, buff_envmap_info);
declare_scene_reflectance_data(s_bary_info, b_bsis_1f, b_coef_4f);

// All includes from and in here rely on buffers/samplers to be declared
#include <render/path.glsl>

void load_shared() {
  const uint iter = hprod(gl_WorkGroupSize.xyz);
  for (uint i = gl_LocalInvocationIndex; i < buff_objects.n; i += iter)  s_objc_info[i] = buff_objects.data[i];
  for (uint i = gl_LocalInvocationIndex; i < buff_objects.n; i += iter)  s_bary_info[i] = buff_coeffs.data[i];
  for (uint i = gl_LocalInvocationIndex; i < buff_meshes.n; i += iter)   s_mesh_info[i] = buff_meshes.data[i];
  for (uint i = gl_LocalInvocationIndex; i < buff_emitters.n; i += iter) s_emtr_info[i] = buff_emitters.data[i];
  memoryBarrierShared();
  barrier();
}

// Initial sample state is seeded from pixel index, and rotated by multiplication
SamplerState get_sampler_state(uvec2 xy, uint i) {
  uint state = 1 + xy.x + xy.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;
  return state * (1 + i);
}

void main() {
  load_shared();

  // Select the correct pixel to render for e.g. checkerboarding
  uvec2 xy = gl_GlobalInvocationID.xy;
  if (bool(buff_sampler_state.pixel_checkerboard))
    xy = xy 
       * uvec2(2, 1) 
       + uvec2((xy.y + buff_sampler_state.pixel_curr) % 2, 0);

  // Clamp invocations to requested size
  guard(all(lessThan(xy, buff_sensor.film_size)));
  
  // Load sensor data
  Sensor sensor = { buff_sensor.proj_trf, buff_sensor.view_trf, buff_sensor.film_size };

  // Running average rgba measure is current value in film
  vec4 measure = imageLoad(b_film, ivec2(xy));
  if (!use_alpha)
    measure.w = 1.f;

  // Take spp_per_iter samples and add to target measure
  for (uint i = buff_sampler_state.spp_curr;
            i < buff_sampler_state.spp_curr + buff_sampler_state.spp_per_iter;
          ++i) {
    // Initialize sampler and generate sensor sample
    SamplerState state         = get_sampler_state(xy, i);
    SensorSample sensor_sample = sample_sensor(sensor, ivec2(xy), i, next_3d(state));

    if (!use_debug) {      
      // Sample incident radiance along ray for given wavelengths, weighted by probabil;ity;
      // optionally capture alpha
      float alpha;
      vec4 L = Li(sensor_sample, state, alpha);

      // If alpha is ignored, we output black
      if (!use_alpha)
        alpha = 1.f;
      
      // Integrate over color system and add to measure in running average
      measure += (vec4(sensor_apply(sensor_sample, L), alpha) - measure) / float(1 + i);
    } else {
      // Instead output debug value
      vec4 L = Li_debug(sensor_sample, state);
      measure += (vec4(sensor_apply(sensor_sample, L), 1) - measure) / float(1 + i);
    }

  } // for (uint spp_iter)
  
  // Store running average measure to film
  imageStore(b_film, ivec2(xy), measure);
}