#include <preamble.glsl>
#include <math.glsl>
#include <spectrum.glsl>
#include <distribution.glsl>
#include <sampler/uniform.glsl>
#include <render/ray.glsl>
#include <render/detail/path_types.glsl>
#include <render/detail/scene_types.glsl>
#include <render/load/bvh.glsl>
#include <render/load/emitter.glsl>
#include <render/load/object.glsl>
#include <render/load/defaults.glsl>

// General layout rule declarations
layout(local_size_x_id = 0) in;
layout(std140) uniform;
layout(std430) buffer;

layout(binding = 0) uniform b_buff_sensor {
  vec3 origin;    /* padd to 16 bytes */ uint p0;
  vec3 direction; /* padd to 16 bytes */ uint p1;
} buff_sensor;
layout(binding = 1) uniform b_buff_objects {
  uint n;
  ObjectInfo data[met_max_objects];
} buff_objects;
layout(binding = 2) uniform b_buff_meshes {
  uint n;
  MeshInfo data[met_max_meshes];
} buff_meshes;
layout(binding = 3) uniform b_buff_emitters {
  uint n;
  EmitterInfo data[met_max_emitters];
} buff_emitters;
layout(binding = 4) uniform b_buff_envmap_info {
  bool envm_is_present;
  uint envm_i;
} buff_envmap_info;

// Storage buffer declarations
layout(binding = 0) restrict readonly buffer b_buff_bvhs_node { 
  BVHNodePack  data[]; 
} buff_bvhs_node;
layout(binding = 1) restrict readonly buffer b_buff_bvhs_prim { 
  MeshPrimPack data[]; 
} buff_bvhs_prim;
layout(binding = 2) restrict coherent buffer b_buff_output { 
  Ray data;
} buff_output;

// Shared memory declarations
shared ObjectInfo  s_objc_info[met_max_objects];
shared EmitterInfo s_emtr_info[met_max_emitters];
shared MeshInfo    s_mesh_info[met_max_meshes];

declare_scene_traversal_stack(8); 
declare_scene_emitter_data(s_emtr_info, buff_emitters.n, buff_envmap_info);
declare_scene_object_data(s_objc_info, buff_objects.n);
declare_scene_bvh_data(buff_bvhs_prim.data, buff_bvhs_node.data, s_mesh_info, buff_meshes.n);
declare_distr_sampler_default(wavelength, buff_wvls_distr, wavelength_samples)
declare_distr_sampler_default(emitters, buff_emitters_distr, met_max_emitters)

// All includes from and in here rely on buffers/samplers to be declared
#include <render/scene.glsl>
#include <render/sensor.glsl>

void load_shared() {
  const uint iter = hprod(gl_WorkGroupSize.xyz);
  for (uint i = gl_LocalInvocationIndex; i < buff_objects.n; i += iter)  s_objc_info[i] = buff_objects.data[i];
  for (uint i = gl_LocalInvocationIndex; i < buff_meshes.n; i += iter)   s_mesh_info[i] = buff_meshes.data[i];
  for (uint i = gl_LocalInvocationIndex; i < buff_emitters.n; i += iter) s_emtr_info[i] = buff_emitters.data[i];
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();

  // Clamp invocations to requested size
  guard(gl_GlobalInvocationID.x == 0);

  // Load sensor data as ray
  Ray ray = init_ray(buff_sensor.origin, buff_sensor.direction);

  // Intersect ray with scene
  scene_intersect(ray);

  // Store result to buffer
  buff_output.data = ray;
}