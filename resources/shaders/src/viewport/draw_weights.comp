#version 460 core

#include <guard.glsl>
#include <math.glsl>

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(std140)             uniform;

// Shader storage buffer declarations
layout(binding = 0) restrict readonly  buffer b_0 { vec4  data[]; } b_bary_in;
layout(binding = 1) restrict readonly  buffer b_1 { vec3  data[]; } b_vert_in;
layout(binding = 2) restrict readonly  buffer b_2 { uvec4 data[]; } b_elem_in;
layout(binding = 3) restrict writeonly buffer b_3 { vec3  data[]; } b_colr_out;

// Constants
const uint max_verts_support = 256;
const uint max_elems_support = 256;

// Uniform buffer declarations
layout(binding = 0) uniform u_0 {
  uint n;
  uint n_verts;
  uint n_elems;
  uint selection[max_verts_support];
} b_unif;

// Shared memory declarations
shared vec3  s_verts_in[max_verts_support]; // Shared load of b_vert_in buffer
shared uvec4 s_elems_in[max_elems_support]; // Shared load of b_elem_in buffer

void load_shared() {
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_verts; i += gl_WorkGroupSize.x)
    s_verts_in[i] = b_vert_in.data[i];
  for (uint i = gl_LocalInvocationID.x; i < b_unif.n_elems; i += gl_WorkGroupSize.x)
    s_elems_in[i] = b_elem_in.data[i];
  memoryBarrierShared();
  barrier();
}

void main() {
  load_shared();
  
  const uint i = gl_GlobalInvocationID.x;
  guard(i < b_unif.n);

  // Load relevant barycentric weights and vertex indices
  uvec4 idx = s_elems_in[floatBitsToUint(b_bary_in.data[i].w)];
  vec3 xyz  = b_bary_in.data[i].xyz;
  vec4 bary = vec4(xyz, 1.f - hsum(xyz));

  // Compute convex combination of vertex colors, negating unselected vertices
  vec3 v = vec3(0);
  for (uint j = 0; j < 4; ++j)
    v += float(b_unif.selection[idx[j]]) * bary[j] * s_verts_in[idx[j]];

  b_colr_out.data[i] = v;
}