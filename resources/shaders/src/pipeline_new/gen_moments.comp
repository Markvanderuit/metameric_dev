#include <preamble.glsl>
#include <math.glsl>
#include <moments.glsl>
#include <spectrum.glsl>
#include <render/detail/scene_types.glsl>

extension(GL_KHR_shader_subgroup_arithmetic, require)
extension(GL_KHR_shader_subgroup_ballot,     require)
extension(GL_KHR_shader_subgroup_clustered,  require)
extension(GL_KHR_shader_subgroup_shuffle,    require)

// General layout rule declarations
layout(local_size_x = 256) in;
layout(std430) buffer;
layout(std140) uniform;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_unif {
  uint object_i;
} unif;

// Storage buffer declarations
layout(binding = 0) restrict readonly buffer b_buff_atlas {
  AtlasLayout data[];
} buff_atlas;

// Image/sampler binding declarations
layout(binding = 0, rgba32f)  uniform readonly image1DArray b_spec_4f; // Uplifting spectrum data
layout(binding = 1, rgba32f)  uniform readonly      image1D b_warp_1f; // Warp data for spectral MESE
layout(binding = 2, rgba32f)  uniform readonly      image2D b_bary_4f; // Uplifting barycentrics data
layout(binding = 3, rgba32ui) uniform writeonly    uimage2D b_coef_4f; // Output coefficients for spectral MESE

// Moment coefficients are stored in shared memory
shared vec2[256 / 32][moment_coeffs] s_coeffs;

void eval(float phase, float phase_next, float signal, float signal_next, bool insert_barriers) {
  guard(phase < phase_next);

  float gradient = (signal_next - signal) / (phase_next  - phase);      
  float y_inscpt = signal - gradient * phase;
  
  for (uint j = 1; j < moment_coeffs; ++j) {
    float rcp_j2 = 1.f / float(j * j);
    float flt_j  = float(j);

    vec2 common_summands = vec2(gradient * rcp_j2, y_inscpt / flt_j);
    vec2 moment_add = subgroupAdd(complex_mult(
      common_summands + vec2(0, gradient * flt_j * phase_next * rcp_j2 ),
      vec2(cos(-flt_j * phase_next), sin(-flt_j * phase_next))
    ));
    vec2 moment_sub = subgroupAdd(complex_mult(
      common_summands + vec2(0, gradient * flt_j * phase * rcp_j2 ),
      vec2(cos(-flt_j * phase), sin(-flt_j * phase))
    ));

    if (subgroupElect()) {
      s_coeffs[gl_SubgroupID][j] += moment_add;
      s_coeffs[gl_SubgroupID][j] -= moment_sub;
    }

    if (insert_barriers) {
      memoryBarrierShared();
      barrier();
    }
  } // for (uint j = 1)

  float moment_add = subgroupAdd(.5f * gradient * sdot(phase_next) + y_inscpt * phase_next);
  float moment_sub = subgroupAdd(.5f * gradient * sdot(phase)      + y_inscpt * phase);

  if (subgroupElect()) {
    s_coeffs[gl_SubgroupID][0] += moment_add;
    s_coeffs[gl_SubgroupID][0] -= moment_sub;
  }

  if (insert_barriers) {
    memoryBarrierShared();
    barrier();
  }
}

void main() {
  uint i = gl_GlobalInvocationID.x / gl_SubgroupSize;

  // Determine wavelengths and their respective indices for each thread
  ivec2 wvls_i = ivec2(2 * gl_SubgroupInvocationID) + ivec2(0, 1);
  vec2 wvls    = (vec2(wvls_i) + .5f) / float(wavelength_samples);

  // Load barycentric coordinates using subgroup broadcast
  vec4 bary;  // Barycentric coordinates describing recombined spectrum in tesselation
  uint index; // Index of relevant tetrahedron inside tesselation
  if (subgroupElect()) {
    AtlasLayout atlas = buff_atlas.data[unif.object_i];
    uvec2 px = atlas.offs + uvec2(i % atlas.size.x, i / atlas.size.x);
    bary = imageLoad(b_bary_4f, ivec2(px));
  }
  bary = subgroupBroadcastFirst(bary);
  guard(!all(is_zero(bary)));
  index = uint(bary.w);
  bary.w = 1.f - hsum(bary.xyz);
  
  // Load phase and signal data for this invocation; the subgroup together
  // describes a full spectral range
  vec2 phase  = vec2(
    imageLoad(b_warp_1f, int(wvls_i.x)).x,
    imageLoad(b_warp_1f, int(wvls_i.y)).x);
  vec2 signal = vec2(
    dot(imageLoad(b_spec_4f, ivec2(wvls_i.x, index)), bary),
    dot(imageLoad(b_spec_4f, ivec2(wvls_i.y, index)), bary));
  
  // Determine phase and signal one index to the right, taking into account end-caps
  vec2 phase_next  = vec2(phase.y, 0.0);
  vec2 signal_next = vec2(signal.y);
  if (gl_SubgroupInvocationID < gl_SubgroupSize - 1) {
    phase_next.y  = subgroupShuffle(phase_next.x,  gl_SubgroupInvocationID + 1);
    signal_next.y = subgroupShuffle(signal_next.x, gl_SubgroupInvocationID + 1);
  }

  // Set coefficients to zero
  if (gl_SubgroupInvocationID < moment_coeffs)
    s_coeffs[gl_SubgroupID][gl_SubgroupInvocationID] = vec2(0);
  memoryBarrierShared();
  barrier();

  // Fit coefficients
  if (subgroupElect())
    eval(-M_PI, phase.x, signal.x, signal.x, false);
  memoryBarrierShared();
  barrier();
  eval(phase.x, phase_next.x, signal.x, signal_next.x, true);
  eval(phase.y, phase_next.y, signal.y, signal_next.y, true);

  // Store coefficients
  if (subgroupElect()) {
    AtlasLayout atlas = buff_atlas.data[unif.object_i];
    uvec2 px = atlas.offs + uvec2(i % atlas.size.x, i / atlas.size.x);

    float[moment_coeffs] v;
    for (uint i = 0; i < moment_coeffs; ++i)
      v[i] = s_coeffs[gl_SubgroupID][i].x * M_PI_INV;

    imageStore(b_coef_4f, ivec2(px), pack_moments_12x10(v));
  }
}