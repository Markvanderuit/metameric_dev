/*
  This shader implements an algorithm for sampling-based generation
  of the 6D Object Color Solid, following the formulation provided by
  Mackiewicz, M., Rivertz, H. J., and Finlayson, G. in  "Spherical
  sampling methods for the calculation of metamer mismatch volumes".
    
  Src: https://opg.optica.org/abstract.cfm?uri=josaa-36-1-96
 */

#version 460 core

// Set NVidia-CG flags
#pragma optionNV(fastmath on)
#pragma optionNV(inline   all)
#pragma optionNV(unroll   all)
#pragma optionNV(strict   on)

// Use shorthand for per-invocation types
#define Spec InSpec
#define CMFS InCMFS
#define Mapp InMapp

#include <guard.glsl>
#include <random_normal.glsl>
#include <mapping_invoc.glsl>
#include <vec6.glsl>

layout(local_size_x = 256) in;
layout(std430)             buffer;
layout(binding = 0) restrict readonly  buffer b_0 { float data[]; } b_rand;
layout(binding = 1) restrict readonly  buffer b_1 { Mapp  data[]; } b_mapp;
layout(binding = 2) restrict writeonly buffer b_2 { vec6  data[]; } b_ovec;

layout(location = 0) uniform uint u_n;
layout(location = 1) uniform uint u_mapping_i;
layout(location = 2) uniform uint u_mapping_j;

shared CMFS s_cs[2]; // Pair of color systems loaded in shared memory

vec6 next_6d_normal(inout uint state) {
  vec6 v;
  for (uint i = 0; i < 6; ++i)
    v.v[i] = next_1d_normal(state);
  return v;
}

void main() {
  const uint i = gl_GlobalInvocationID.x;
  guard(i < u_n);

  // Compute color systems and store these in shared memory
  if (gl_LocalInvocationID.x < 2) {
    const uint u_mapping = gl_LocalInvocationID.x == 0 ? u_mapping_i : u_mapping_j;
    s_cs[gl_LocalInvocationID.x] = finalize_mapp(b_mapp.data[u_mapping]);
  }
  memoryBarrierShared();
  barrier();

  // Sample a random unit vector:  gaussian distr maps to a uniform distribution 
  // over the surface of an N-dimensional hypersphere
  uint state = i;
  vec3 u = normalize(next_3d_normal(state));

  // 6d OCS vector
  vec6 c;
    
  // Compute first three components of 6d OCS vector based on color system i
  {
    Spec a_i = in_mmul(u, s_cs[0]);
    Spec r_i = in_select(in_gr(a_i, 0.f), 1.f, 0.f);
    vec3 c_i = in_mmul(s_cs[0], r_i);
    store_first(c, c_i);
  }

  // Compute last three components of 6d OCS vector based on color system j
  {
    Spec a_j = in_mmul(u, s_cs[1]);
    Spec r_j = in_select(in_gr(a_j, 0.f), 1.f, 0.f);
    vec3 c_j = in_mmul(s_cs[1], r_j);
    store_second(c, c_j);
  }

  // Store result to buffer
  b_ovec.data[i] = c;
}