/*
  This shader implements an algorithm for sampling-based generation
  of the Object Color Solid, following the formulation provided by
  Mackiewicz, M., Rivertz, H. J., and Finlayson, G. in  "Spherical
  sampling methods for the calculation of metamer mismatch volumes".
    
  Src: https://opg.optica.org/abstract.cfm?uri=josaa-36-1-96
 */

#version 460 core

// Set NVidia-CG flags
#pragma optionNV(fastmath on)
#pragma optionNV(inline   all)
#pragma optionNV(unroll   all)
#pragma optionNV(strict   on)

#include <guard.glsl>
#include <random_normal.glsl>
#include <mapping_invoc.glsl>

layout(local_size_x = 256) in;
layout(std430)             buffer;

layout(binding = 0) restrict readonly  buffer b_0 { Mapp  data[]; } b_mapp;
layout(binding = 1) restrict writeonly buffer b_1 { Spec  data[]; } b_oopt;
layout(binding = 2) restrict writeonly buffer b_2 { vec3  data[]; } b_ovec;

layout(location = 0) uniform uint  u_n;
layout(location = 1) uniform uint  u_mapping_i;
layout(location = 2) uniform float u_time;
 
// Gaussian variables map to a uniform distribution over
// the surface of an N-dimensional hypersphere
vec3 next_uniform_spherical_3(inout uint state) {
  return normalize(next_3d_normal(state)); 
}

void main() {
  const uint i = gl_GlobalInvocationID.x;
  guard(i < u_n);

  // Sample a random unit vector:  gaussian distr maps to a uniform distribution 
  // over the surface of an N-dimensional hypersphere
  uint state = i;
  vec3 u = normalize(next_3d_normal(state));

  // Obtain color system (spectra) from mapping data
  CMFS cs = finalize_mapping(b_mapp.data[u_mapping_i]);

  // Generate the algorithm's matrix A_ij, and then the optimal spectrum R_ij and its mapped color
  Spec a_ij = in_matmul(u, cs);
  Spec r_ij = in_select(in_ge(a_ij, 0.f), 1.f, 0.f);
  vec3 c_ij = in_matmul(cs, r_ij);

  // Store results to buffers
  b_oopt.data[i] = r_ij;
  b_ovec.data[i] = c_ij;
}