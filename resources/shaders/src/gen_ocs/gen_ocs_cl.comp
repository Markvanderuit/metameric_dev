/*
  This shader implements an algorithm for sampling-based generation
  of the Object Color Solid, following the formulation provided by
  Mackiewicz, M., Rivertz, H. J., and Finlayson, G. in  "Spherical
  sampling methods for the calculation of metamer mismatch volumes".
    
  Src: https://opg.optica.org/abstract.cfm?uri=josaa-36-1-96
 */

#version 460 core

// Enable necessary subgroup extensions
#extension GL_KHR_shader_subgroup_basic      : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_clustered  : require

// // Set NVidia-CG flags
// #pragma optionNV(fastmath on)
// #pragma optionNV(inline   all)
// #pragma optionNV(unroll   all)
// #pragma optionNV(strict   on)

// Use shorthand for clustered types
#define Spec ClSpec
#define CMFS ClCMFS
#define Mapp ClMapp

#include <guard.glsl>
#include <random_normal.glsl>
#include <mapping_invoc.glsl>
#include <mapping_cluster.glsl>

layout(local_size_x = 256) in;
layout(std140)             uniform;
layout(std430)             buffer;

layout(binding = 0) restrict readonly  buffer b_0 { InMapp data[]; } b_mapp;
layout(binding = 1) restrict writeonly buffer b_1 { InSpec data[]; } b_oopt;
layout(binding = 2) restrict writeonly buffer b_2 { vec3   data[]; } b_ovec;
layout(binding = 0) uniform u_0 {
  uint n;
  uint mapping_i;
} b_unif;
 
shared InMapp s_mapping;

// Load mapping data into shared memory
void load_mapp_shared_in() {
  const uint mapping_i = b_unif.mapping_i;
  const uint i = gl_LocalInvocationID.x % wavelength_samples_al;
  const uint j = gl_LocalInvocationID.x / wavelength_samples_al;

  if (j < 3 && i < wavelength_samples) 
    s_mapping.cmfs[j][i] = b_mapp.data[mapping_i].cmfs[j][i];
  if (j == 0 && i < wavelength_samples)  
    s_mapping.illuminant[i] = b_mapp.data[mapping_i].illuminant[i];
  
  memoryBarrierShared();
  barrier();
}

// Load clustered mapping from shared memory
Mapp load_mapp_shared_cl() {
  Mapp s;
  cl_mapp_scatter(s, s_mapping);
  return s;
}

// Store clustered spectrum to b_oopt buffer
void store_oopt(in Spec s, uint i) {
  cl_spec_gather(b_oopt.data[i], s);
}

// Store clustered vector to b_ovec buffer
void store_ovec(in vec3 v, uint i) {
  guard(cl_bin_elect());
  b_ovec.data[i] = v;
}

void main() {
  const uint i = gl_GlobalInvocationID.x / cl_spectrum_invc_n;
  guard(i < b_unif.n);

  // Load mapping data into shared memory
  load_mapp_shared_in();

  // Sample a random unit vector; a normalized point in an N-D gaussian distr. maps 
  // to a uniform distribution over the surface of an N-D hypersphere
  uint state = i;
  vec3 u = normalize(next_3d_normal(state));

  // Obtain color system (spectra) from the mapping currently in shared memory
  CMFS cs = finalize_mapp(load_mapp_shared_cl());

  // Generate the algorithm's matrix a_ij, followed by optimal spectrum r_ij and color c_ij
  Spec a_ij = cl_mmul(u, cs);
  Spec r_ij = cl_select(cl_ge(a_ij, 0.f), 1.f, 0.f);
  vec3 c_ij = cl_mmul(cs, r_ij);

  // Store results to buffers
  store_oopt(r_ij, i);
  store_ovec(c_ij, i);
}