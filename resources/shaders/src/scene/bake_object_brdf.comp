#include <preamble.glsl>
#include <math.glsl>
#include <render/record.glsl>
#include <render/load/defaults.glsl>

// General layout rule declarations
layout(local_size_x = 16, local_size_y = 16) in;
layout(std430) buffer;
layout(std140) uniform;

// Uniform buffer declarations
layout(binding = 0) uniform b_buff_unif {
  uint object_i;

  uint  object_metallic_data;
  uint  object_roughness_data;
  uint  object_transmission_data;

  uvec2 object_albedo_data;
  uint  object_normalmap_data;
  uint  object_data_y;
  uint  object_data_z;
} buff_unif;
layout(binding = 1) uniform b_buff_atlas {
  uint n;
  AtlasInfo data[met_max_textures];
} buff_atlas;
layout(binding = 2) uniform b_buff_textures {
  uint n;
  TextureInfo data[met_max_textures];
} buff_textures;

// Image/sampler declarations
layout(binding = 0)          uniform sampler2DArray                  b_txtr_3f; // Input 3-component textures
layout(binding = 1)          uniform sampler2DArray                  b_txtr_1f; // Input 1-component textures
layout(binding = 0, rgba32f) uniform restrict writeonly image2DArray b_atlas;   // Output coefficient texture atlas

float read_record_data_float(in uint rc) {
  float f;
  if (record_is_index(rc)) {
    // Determine pixel location in texture atlas
    TextureInfo txtr = buff_textures.data[record_get_index(rc)];
    const uvec2 px_in = clamp(gl_GlobalInvocationID.xy + txtr.offs, txtr.offs, txtr.offs + txtr.size - 1);

    // Value is supplied by scene texture; could be b_txtr_3f or b_txtr_1f
    if (txtr.is_3f) {
      const vec2 tx_in = clamp((vec2(px_in) + 0.5f)
                       / textureSize(b_txtr_3f, 0).xy, vec2(0), vec2(1));
      f = texture(b_txtr_3f, vec3(tx_in, txtr.layer)).x;
    } else {
      const vec2 tx_in = clamp((vec2(px_in) + 0.5f)
                       / textureSize(b_txtr_1f, 0).xy, vec2(0), vec2(1));
      f = texture(b_txtr_1f, vec3(tx_in, txtr.layer)).x;
    }
  } else {
    f = record_get_value(rc);
  }
  return f;
}

vec3 read_record_data_vec3(in uint rc) {
  vec3 v;
  if (record_is_optional_set(rc)) {
    TextureInfo txtr  = buff_textures.data[record_get_optional_value(rc)];
    const uvec2 px_in = clamp(gl_GlobalInvocationID.xy + txtr.offs, txtr.offs, txtr.offs + txtr.size - 1);
    
    // Value is supplied by scene texture; should only allow b_txtr_3f
    if (txtr.is_3f) {
      const vec2 tx_in = clamp((vec2(px_in) + 0.5f)
                       / textureSize(b_txtr_3f, 0).xy, vec2(0), vec2(1));
      v = normalize(texture(b_txtr_3f, vec3(tx_in, txtr.layer)).xyz * 2.f - 1.f);
    } else {
      // Fallback
      v = vec3(0, 0, 1);
    }
  } else {
    // Fallback
    v = vec3(0, 0, 1);
  }
  return v;
}

void main() {
  // Load relevant object/patch data
  AtlasInfo atlas = buff_atlas.data[buff_unif.object_i];

  // Determine pixel location in padded patch, then clamp invocations to
  // relevant region; the atlas patch plus a 2px padding border for oversampling
  const uvec2 px_out = gl_GlobalInvocationID.xy + atlas.offs;
  guard(clamp(px_out, atlas.offs, atlas.offs + atlas.size - 1) == px_out);

  // Read brdf data records, then sample texture or extract scalar from said records
  float metallic     = read_record_data_float(buff_unif.object_metallic_data);
  float roughness    = read_record_data_float(buff_unif.object_roughness_data);
  float transmission = read_record_data_float(buff_unif.object_transmission_data);
  vec3  normalmap    = read_record_data_vec3(buff_unif.object_normalmap_data);

  // Repack sampled brdf data
  uvec4 brdf_data;
  brdf_data.x = ((pack_unorm_10(metallic)     & 0x03FF)      )
              | ((pack_unorm_10(roughness)    & 0x03FF) << 10)
              | ((pack_unorm_10(transmission) & 0x03FF) << 20);
  brdf_data.y = buff_unif.object_data_y; // forwarded
  brdf_data.z = buff_unif.object_data_z; // forwarded
  brdf_data.w = packUnorm2x16(pack_normal_octahedral(normalmap));

  // Finally, write packed result out to atlas
  imageStore(b_atlas, ivec3(px_out, atlas.layer), uintBitsToFloat(brdf_data));
}