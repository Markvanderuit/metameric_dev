#version 460 core

#include <guard.glsl>
#include <spectrum_invoc.glsl>

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0, std430) restrict readonly  buffer b_0 { vec3 b_0_color_gamut[4];      };
layout(binding = 1, std430) restrict readonly  buffer b_1 { Spec b_1_spectral_gamut[4];   };
layout(binding = 2, std430) restrict readonly  buffer b_2 { vec3 b_2_color_texture[];     };
layout(binding = 3, std430) restrict writeonly buffer b_3 { Spec b_3_spectral_texture[];  };

layout(location = 0) uniform uint u_n;
layout(location = 1) uniform mat3 u_barycentric_transform;

vec4 to_barycentric(in vec3 p) {
  // TODO preprocess this matrix+vector in uniforms instead
  mat3 t = inverse(mat3(b_0_color_gamut[0] - b_0_color_gamut[3],
                        b_0_color_gamut[1] - b_0_color_gamut[3],
                        b_0_color_gamut[2] - b_0_color_gamut[3]));
  vec3 abc = t * (p - b_0_color_gamut[3]);
  return vec4(abc, 1.f - in_hsum(abc));
}

void main() {
  const uint i = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
  guard(i < u_n);

  /*
    1. Obtain a value at i in the color texture.
    2. Compute the barycentric coordinates of this value in the color gamut
    3. Multiply the spectra in the spectral gamut based on the coordinates
    4. Store the value at i in the spectral texture
  */

  vec4 abcd = to_barycentric(b_2_color_texture[i]);

  Spec sd = in_mul(b_1_spectral_gamut[0], abcd[0]);
       sd = in_add(sd, in_mul(b_1_spectral_gamut[1], abcd[1]));
       sd = in_add(sd, in_mul(b_1_spectral_gamut[2], abcd[2]));
       sd = in_add(sd, in_mul(b_1_spectral_gamut[3], abcd[3]));

  b_3_spectral_texture[i] = sd;
}